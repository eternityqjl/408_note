第2、3节定点数和浮点数可能考大题。

## 数制与编码

### 进位计数制机器相互转换

**进位计数法**

二进制、八进制、十进制、十六进制

**不同进制之间的相互转换**

* 二进制转换为八进制和十六进制：将一串二进制数分为**3位一组或4位一组，补零**，然后分别用八进制或十六进制数代替。
* 任意进制转换为十进制：各位数码与权值相乘，再把乘积相加
* 十进制转化为任意进制数：基数乘除法，对十进制数的整数和小数部分分别处理，整数部分采用**除基取余法**（最先取得的余数为最低位，最后取得的余数为最高位），小数部分采用**乘基取整法**（最先取得的整数位最高位，最后取得的整数位为最低位）。

### 真值和机器数

真值：正负数，是机器数代表的实际值

机器数：把真值数字化为寄存存储的数，常用的有原码、反码、补码

### BCD码

用二进制编码的十进制数，通常用4位二进制数表示一位十进制数字。

8421码：大于1010时要加6修正。

### 字符与字符串

ASCII编码：使用7位二进制编码（每个字节的最高位保持为0，可用于传输时的奇偶校验），可以表示10个十进制数、52个大小写英文字母，以及一些专用符号。

* 编码值0-31：控制字符
* 编码值127是DEL码；编码值32是空格SP
* 编码值32-126：可印刷字符

0-9的ASCII值为48-57

**汉字的编码和表示**

汉字的编码包括汉字的**输入编码、汉字内码、汉字字形码**三种，是计算机用于输入、内部处理、输出的三种编码。

国标码、区位码、汉字内码。

### 校验码

数据校验码的码距：任意两个合法码字**之间**最少变化的二进制位数

对于码距**不小于2**的数据校验码，开始具有检错能力。

**奇偶校验码**

实现方法：由若干有效信息加上一个二进制位（校验位）组成校验码，校验码的取值（0或1）将使得整个校验码中**1的个数为偶数或奇数**。

* 奇校验码：整个校验码中1的个数为奇数
* 偶校验码：整个校验码中1的个数为偶数

**海明校验码**

在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中，当某一位出错后，就会引起有关的几个校验位的值发生变化，这样不但能发现错位，还能指出错位的位置，然后直接进行纠错。

以数据码1010为例讲述海明码的编码原理：

* 确定海明码的位数：

设n为有效信息位数，k为校验位的位数，则n和k应该满足：
$$
n+k\leq 2^k -1 
$$
海明码位数为$n+k=7\leq 2^3-1$成立，则n、k有效。设信息位为$D_4D_3D_2D_1$（1010），校验位为$P_1P_2P_3$，共三位，对应的海明码为$H_7H_6H_5H_4H_3H_2H_1$。

* 确定校验位的分布

规定校验位$P_i$在海明位号为$2^{i-1}$的位置上，其余各位为信息位：

$P_1$的海明位号为1，即$H_1$为$P_1$；

$P_2$的海明位号为2，即$H_2$为$P_2$；

$P_3$的海明位号为4，即$H_4$为$P_3$；

将信息位按照原来的顺序插入，则分布如下：



* 分组以形成校验关系

每个数据位用多个校验位进行校验，但要满足：被校验**数据位的海明位号**等于校验该数据位的各**校验位的海明位号之和**。

![](https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E5%88%86%E7%BB%84.jpg)

* 校验位取值

校验位$P_i$的值为第i组所有位（由该校验位校验的所有数据为）的异或：
$$
P_1=D_1\oplus D_2\oplus D_4 = 0 \\
P_2=D_1\oplus D_3\oplus D_4 = 1 \\
P_3=D_2\oplus D_3\oplus D_4 = 0 \\
$$
所以1010对应的海明码为1010010

* 海明码的校验原理：

每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成k各校验方程：
$$
S_1=P_1\oplus D_1\oplus D_2\oplus D_4 \\
S_2=P_2\oplus D_1\oplus D_3\oplus D_4 \\
S_3=P_3\oplus D_2\oplus D_3\oplus D_4 \\
$$
若$S_1S_2S_3$的值为000，则说明无错；否则说明出错，这个数就是错误的位号，如$S_1S_2S_3=001$，说明第一位出错，直接将该位取反就可以纠错。

**CRC码**

在K位信息后在拼接R位的校验码，整个编码的长度为N，因此又称为(N, K)码

CRC码基于线性编码理论。在发送端，将要发送的K位二进制数左移R位，然后将其与生成多项式G(x)作模2除法（异或），生成一个R位校验码，并附在信息码后，构成一个新的二进制码（CRC码），共K+R位。在接收端，利用生成多项式对收到的编码作模2除法，以检测和确定出错的位置，如果无错则整除。生成多项式是发送端和接收端的一种约定。

生成多项式G(x)的最高次幂为R，转换成对应的二进制数有R+1位。

详细例子见书上。

## 定点数的表示和运算

### 定点数的表示

**无符号数和有符号数**

* 无符号数：整个机器字长的所有二进制位**均为数值位，没有符号位**

* 有符号数：有符号数用**0表示正号，用1表示负号**，从而将符号数值化，通常约定二进制数的**最高位**为符号位。

有符号数的**机器表示**有**原码、补码、反码和移码**。

**机器数的定点表示**

根据**小数点的位置是否固定**，计算机中有两种数据格式：定点表示和浮点表示。

定点表示约定机器数中的小数点位置固定不变，计算机中通常采用两种简单的约定：将小数点固定在**最高位之前(定点小数)**，或固定在**最低位之后(定点整数)**。

* 定点小数：是**纯小数**，约定小数点位置在符号位之后，有效数值部分最高位之前。表示范围为$1-2^{-n} \to -(1-2^{-n})$
* 定点整数：是**纯整数**，约定小数点位置在有效数值部分最低为之后。

二者的格式图见书上所示。

计算一个**有符号数的原码、反码、补码、移码**是**不用区分**这个数是定点小数还是定点整数，直接按照以下规则进行计算即可。

**原码、补码、反码、移码**

* **原码**：用机器数的**最高位**表示该数的**符号**，其余各位表示数的绝对值
* **补码**：补码中的加减法统一采用加法操作实现
  * 正数的补码与原码相等
  * 负数的补码等于对应正数取反后加1
* **反码**：由原码求补码或补码求原码的**中间过渡**
  * 正数的反码与原码相等
  * 负数的反码等于对应正数按位取反
* **移码**：用来表示**浮点数的阶码**，只能表示整数。
  * $[x]_{移}=2^n+x$，其中机器字长为n+1
  * 一个真值的移码和补码仅差一个符号位，**补码**的**符号位取反**就可得到移码
  * 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小

### 定点数的运算

**移位运算**

分为算术移位和逻辑移位，**有符号数**的移位称为**算术移位**，**逻辑移位**的操作对象是逻辑代码，可视为**无符号数**。

* 算术移位：正数的原码、补码和反码都相同，移位后添0即可；**负数**依据**编码形式**不同而不同，负数原码添0；补码左移添0，右移添1；反码添1。
* 逻辑移位：逻辑左移时高位移丢，低位添0；逻辑右移时，低位丢失，高位添0.
* 循环移位：适合将数据的低字节数据和高字节数据互换

**原码定点数的加减法运算**

将符号位和数值位分开计算。

**补码定点数加减法运算**

直接将补码进行相加计算即可得到结果的补码。

**符号扩展**

把采用给定位数表示的数转换成具有不同位数的某种表示形式。

**溢出**

运算结果超出了数的表示范围。

上溢和下溢。

溢出的判断法：

* 一位符号法：只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出
* 双符号位法：模4补码

**定点数的乘法运算**

累加和右移操作实现。

* **原码一位乘法**

符号位与数值位**分开求**。符号位由两个数的**符号位异或**形成；乘积的数值部分则是两个数的**绝对值相乘之积**。

* 补码一位乘法（Booth算法）

采用相加和相减操作计算补码数据的乘积。

**定点数的除法运算**

累加和左移实现。

* 原码除法运算

商符和商值是分开进行的，商符由两个操作数的符号位异或形成。

* 补码除法运算（加减交替法）

符号参与运算，运算中的所有数均使用补码表示。若对商的精度没有特殊要求，一般采用末位恒置为1法。

### C语言中的整数类型及类型转换

C语言变量之间的类型转换是常出现的题目。

**有符号数和无符号数的转换**

在不同数据类型之间作**强制类型转换**。强制类型转换的结果**保持位值不变，仅改变了解释这些位值的方式**。

**不同字长整数之间的转换**

* 大字长变量向小字长变量转换：把**多余高位字长部分直接截断，低位直接赋值**。
* 短字长整数向长字长整数转换：不仅相应的位值相等，**高位部分**还会扩展为**原数字的符号位**。这样的方式保证了数值相等。

### 数据的存储和排列

**存储方法：大端法和小端法**

大端法：按从最高有效字节到最低有效字节的顺序存储数据，即**最高有效字节放在最前面，地址最小**。

小端法：从最低有效字节到最高有效字节存储数据，**最低有效字节放在最前面，地址最小**。

**数据按边界对齐方式存储**

假设存储字长为32位（每次访存读取1个字，即4字节），可按**字节、半字和字**进行寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。所存储的数据不满足以上要求时通过，通过填充空白字节使其符合要求。虽然浪费了一些空间，但能提高取指令和取数的速度。

RISC中如ARM采用边界对其，CISC如X86对齐和不对其都支持。对齐方式取指令时间相同，因此能适应指令流水。

## 浮点数的表示和运算

### 浮点数的表示

以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样在位数有限的情况下既扩大了数的表示范围，又保持了数的有效精度。

**浮点数的表示格式**
$$
N=r^{E}\times M
$$
r为浮点数**阶码的底**，与尾数的基数相同，一般为2。E和M都是有符号的定点数，E称为**阶码**，M称为**尾数**。

浮点数的一般格式：

| 阶符  | 阶码的数值部分 | 数符  | 尾数的数值部分 |
| :---: | :------------: | :---: | :------------: |
| $J_f$ | $J_1J_2...J_m$ | $S_f$ | $S_1S_2...S_n$ |

**阶符**$J_f$和**阶码**的位数m共同反映了浮点数的表示范围和小数点的实际位置；**数符**代表浮点数的符号；**尾数**的位数n反映了浮点数的精度。

**规格化浮点数**

为了提高浮点数精度，充分利用尾数的有效位，通常采用浮点数规格化形式，即规定**尾数的最高数位必须为一个有效值**，类似于数学中科学计数法的规范。

规格化操作是通过调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在尾数的最高位数上保证是一个有效值。

* 左规
* 右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算术左移一位、阶码减1（基数为2）的方法。需要右规时，只需要进行一次。



**IEEE 754标准**

该标准规定了常用的浮点数格式如下所示：

| 数符  | 阶码部分，用移码表示 | 尾数部分，用原码表示 |
| :---: | :------------------: | :------------------: |
| $m_s$ |         $E$          |         $M$          |

IEEE 745标准规定常用浮点数格式有：

* 短浮点数（单精度，float型）：总共32位
* 长浮点数（双精度，double型）：总共64位
* 临时浮点数：总共80位

详细信息见书上表格。

该标准中除了临时浮点数外，**尾数采用隐藏位策略**，即采用二进制表示的规范化浮点数中，尾数的整数部分为1，将这个1隐含。

**阶码**是以**移码**的形式存储的。对于短浮点数，偏置值为**127**；对于长浮点数，偏置值为**1023**。存储浮点数阶码部分之前，**偏置值要先加到阶码真值上**。

IEEE 754中的规范化短、长浮点数的真值计算公式如下所示：
$$
(-1)^s\times 1.M\times 2^{E-127} \\
(-1)^s\times 1.M\times 2^{E-1023}
$$
**定点、浮点表示的区别**

* 数值的表示范围

二者字长相同的情况下，浮点数表示法能表示的数值范围将远远大于定点表示法。

* 精度

字长相同情况下，浮点数的**精度降低**了。

* 数的运算

浮点数运算时既要进行**尾数**的运算，还要进行**阶码**的运算，并且还要求规格化，相比定点数的运算更为复杂。

### 浮点数的加减运算

阶码运算和尾数运算分开进行。浮点数的加减运算一律采用**补码**。共分为以下步骤：

**对阶**

使两个操作数的**小数点位置对齐**，即使得两个数的**阶码相同**。

为此要先求阶差，然后以小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为2），阶加1，知道两个数的阶码相等。

**尾数求和**

将对阶后的尾数按定点数加减运算规则运算。

**规格化**



**舍入**

在对阶和右规的过程中可能会将尾数低位丢失，引起误差，影响精度。常见的舍入方法有：

* 0舍1入法：类似于十进制数运算中的四舍五入，在尾数右移时，被移去的最高数值位为0则舍去；被移去的最高数值位为1，则在尾数的末位加1.
* 恒置1法：尾数右移时，不论丢弃的最高数值是1还是0，都使右移后的尾数末位恒置1。

**溢出判断**

浮点数的溢出与否由阶码的符号决定。



**C语言中的浮点数类型及其转化**

C语言中的float和double类型对应于IEEE 754的单精度浮点数和双精度浮点数。long double类型对应于扩展双精度浮点数，但long double的长度和格式随编译器和处理器类型的不同而有所不同。C程序等式中赋值和判断语句会出现强制类型转换。

## 算术逻辑运算（ALU）

计算机中，运算器执行各种算术和逻辑运算，运算器由算术逻辑单元（ALU）、累加器、状态寄存器、通用寄存器等组成。ALU的基本功能包括加减乘除**四则运算**，与或非异或等**逻辑运算**，以及**移位、求补**等操作。

计算机运行时，运算器的操作和操作种类由控制器决定，运算器处理的数据来自存储器，处理后的结果数据通常送回存储器或暂存在运算器中。

### 串行加法器和并行加法器

ALU的核心部件为加法器，加法器由**全加器**再配以其他必要逻辑电路组成。根据组成加法器的**全加器个数是单个或多个**，将加法器分为**串行和并行**。

**一位全加器FA**

是最基本的加法单元，有加数1、加数2与低位传来的进位共三个输入，有本位和向最高位的进行共两个输出。



**串行加法器**

只有一个全加器，数据**逐位**串行送入加法器中进行运算。若操作数长n位，则加法就要**分n次**进行，每次产生**一位和**，并串行地**送回寄存器**。**进位触发器**用来寄存**进位信号**，以便参与下一次运算。

**并行加法器**

由多个全加器组成，其位数与机器字长相同，各位数据同时运算。存在**最长运算时间**问题，主要由进位信号的传递时间决定。

并行加法器的进位通常分为**串行进位**和**并行进位**。

（1）串行进位





（2）并行进位





### 算术逻辑单元的功能和结构

**带标志加法器**

能够进行带符号整数的加减运算，还能生成相应的标志信息。



**算术逻辑单元ALU**

加减乘除运算最终都能归结为加法运算，ALU的核心是带标志加法器，同时也能执行逻辑运算。另外还具有操作控制端ALUop，来决定ALU所执行的处理功能，其位数决定了操作的种类。

**补码加减运算部件**

假设一个数的补码表示为Y，则这个数的负数的补码为$\overline{Y}+1$，只要在原加法器的Y输入端加n个反向器实现按位取反，然后加一个二选一多路选择器，用一个控制端Sub来控制，以选择将原码Y输入加法器还是将$\overline{Y}$输入，并将Sub同时作为低位进位送到加法器。Sub为1时做减法，Sub为0时做加法。

