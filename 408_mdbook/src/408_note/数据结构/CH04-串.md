**字符串**简称串，计算机上所有非数值处理的对象基本都是字符串数据。本章将详细介绍字符串的存储结构及相应的操作。

## 串的定义和实现

### 定义

串是由**零个或多个**字符组成的有限序列，一般记为：
$$
S='a_1a_2 \cdot\cdot\cdot a_n' \ (n\geq 0)
$$
S为串名，单引号括起来的为字符序列为串的值，$a_i$可以是字母、数字或其他字符，串中字符的个数n称为串的长度。

n=0时的串称为空串。

字串：串中**任意多个连续的字符**组成的子序列；包含子串的串称为**主串**；某个字符在串中的序号称为该字符在串中的位置；子串在主串中的位置以**子串的第一个字符在主串中的位置**来表示。当两个串的长度相等并且每个对应位置的字符都相等时，称这两个串是相等的。

### 串的存储结构

**定长顺序存储**

类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。为每个串分配一个固定长度的存储区，即定长数组。

```c
#define MAXLEN 255;	//预定最大串长为255
typedef struct {
	char ch[MAXLEN];	//每个分量存储一个字符
	int length;	//串的实际长度
}SString;
```

串的实际长度只能小于等于MAXLEN，超过这个长度的串值会被舍去，称为**截断**。

串长有两种表示方法：

* 像定义描述的那样，用一个额外变量len来存放串的长度
* 在串值后面加一个不计入串长的结束标记字符`\0`，此时串长为隐含值

**堆分配存储**

仍然以一块连续的存储单元存放串值的字符序列，但他们的存储空间是动态分配的。

```c
typedef struct {
	char *ch;	//按照串长分配存储区，ch指向串的基地址
	int length;	//串的长度
}HString;
```

C语言中，存在一个称为**堆**的自由存储区，并用malloc()和free()函数来完成动态存储管理。利用malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功则返回一个指向起始地址的指针，作为串的基地址；若分配失败则返回NULL。已分配的空间可以用free()释放。

**块链存储**

类似于线性表的链式存储。在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。

### 串的基本操作

* StrAssign(&T, chars)：赋值操作。把串T赋值为chars
* StrCompare(S, T)：比较操作。若S>T则返回值>0；若S=T，则返回值=0；若S<T，则返回值<0
* StrLength(S)：求串长。返回串S的元素个数
* Concat(&T, S1, S2)：串联接。由T返回由S1和S2联接的新串
* SubString(&Sub, S, pos, len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串

以上5种操作构成串类型的最小操作子集，即这些操作不能利用其他串操作来实现。

## 串的模式匹配

### 简单模式匹配算法

**子串的定位操作**称为模式匹配。他求的是子串在主串中的位置。这里采用一种暴力匹配算法：

```c
int Index(SString S, SString T) {	//S为主串，T为模式
    int i = 1, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i] == T.ch[j]) {
            ++i; ++j;	//继续比较后继字符
        }
        else {
            i = i - j + 2;	//指针后退重新开始匹配
            j = 1;
        }
    }
    if(j > T.length)	return i - T.length;
    else return 0;
}
```

该算法的思想是：从主串S的第一个字符起，与模式T的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功。

该算法的最坏时间复杂度为O(nm)，n和m分别为主串和匹配模式串的长度。

### KMP算法

**一些概念**

* 前缀：除最后一个字符外，字符串的所有头部子串
* 后缀：除第一个字符外，字符串的所有尾部子串
* 部分匹配值：字符串的前缀和后缀的**最长相等前后缀长度**

例如，字符串'ababa'的部分匹配值为00123



在部分匹配的过程中，先写出子串的部分匹配值，得到部分匹配值表，然后开始匹配：

* **每次移动的位数=已匹配的字符数-对应的部分匹配值**

整个匹配过程主串始终没有回退，所以KMP算法可以在O(m+n)的时间数量级上完成串的模式匹配操作。

**KMP算法的原理**

将PM表右移一位，第一个元素右移以后的空缺用-1填充，最后一个元素在右移过程中溢出，无须该元素，可以舍去。这样就**得到了next数组**。

更进一步的改进：将next数组整体加1，就得到了新的next数组，此时子串指针的变化公式为$j=next[j]$。

$next[j]$的含义是在子串的第j个字符与主串发生失配时，则跳到子串的next[j]位置重新与主串的当前位置进行比较。

```c
int Index_KMP(String S, String T, int next[]) {
    
}
```

