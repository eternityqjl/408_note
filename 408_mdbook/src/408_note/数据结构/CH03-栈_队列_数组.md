## 栈

### 基本概念

**定义**

栈（stack）是只允许在一端插入或删除操作的线性表。

* 栈顶：允许进行插入删除的那一端
* 栈底：不允许进行插入删除操作的另一端，是固定的

栈的特性可以概括为**后进先出**

**栈的基本操作**

* `InitStack(&S)`：初始化一个空栈S
* `StackEmpty(S)`：判断一个栈是否为空
* `Push(&S, x)`：进栈，若栈S未满，将x加入使之称为新栈顶
* `Pop(&S, &x)`：出栈，若栈S非空，则弹出栈顶元素，用x返回
* `GetTop(S, &x)`：读栈顶元素
* `DestroyStack(&S)`：销毁栈S，并释放其占用的内存

解答算法题时，一般可以直接使用这些基本函数。

### 顺序存储结构

**顺序栈的实现**

利用一组地址连续的存储单元存放**自栈底到栈顶**的数据元素，同时附设一个指针(top)指示当前栈顶元素。

```c
#define MaxSize 50	//定义栈中最大元素个数
typedef struct{
	Elemtype data[MaxSize];	//存放栈中元素
	int top;	//栈顶指针
} SqStack;
```

* 栈顶指针：**S.top**，初始时设置为-1；栈顶元素：`S.data[S.top]`
* 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素
* 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减去1
* 栈空条件：`S.top=-1`；栈满条件：`S.top=MaxSize-1`；栈长：`S.top+1`

顺序栈的入栈操作收到数组上界的约束，要注意可能发生的栈溢出。

**顺序栈的基本运算**

* 初始化

```c
void InitStack(SqStack &S){
	S.top = -1;
}
```

* 判断栈空

```c
bool StackEmpty(SqStack S){
	if (S.top == -1)
		return true;
	else
		return false;
}
```

* 进栈

```c
bool Push(SqStack &S, ElemType x){
	if (S.top == MaxSize - 1)
		return false;
	S.data[++S.top] = x;
	return true;
}
```

* 出栈

```c
bool Pop(SqStack &S, ElemType &x){
	if (S.top == -1)
		return false;
	x = S.data[S.top--];	//先出栈，指针再减1
	return true;
}
```

* 读栈顶元素

```c
bool GetTop (SqStack S, ElemType &x) {
    if (S.top = -1)
        return false;
    x = S.data[S.top];	//取栈顶元素
    return true;
}
```

**共享栈**

利用栈底位置相对不变的特定，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向空间的中间延申。

### 链式存储结构

链栈的优点是便于**多个栈共享存储空间和提高其效率**，且不存在栈满上溢的情况。通常采用单链表来实现，并且规定所有操作在单链表的**表头**完成。

这里规定链栈没有头结点，Lhead指向栈顶元素。

```c
typedef struct Linknode{
	ElemType data;			//数据域
	struct Linknode *next;	//指针域
} *LiStack;		//栈类型定义
```

链栈操作与链表类似，入栈和出栈操作都在表头进行。

## 队列

### 基本概念

**定义**

也是一种受限的线性表，只允许在**表的一端进行插入**，而在**另一端进行删除**。向队列中插入元素称为**入队**，删除元素称为**出队**。操作特性是**先进先出**。

**基本操作**

* `InitQueue(&Q)`：初始化队列，构造一个空队列
* `QueueEmpty(Q)`：判断队列是否为空
* `EnQueue(&Q, x)`：入队，若队列未满，将x加入，使之称为新队列
* `DeQueue(&Q, &x)`：出队，若队列非空，删除队头元素并用x返回
* `GetHead(Q, &x)`：读队头元素，若队列Q非空，则将队头元素赋值给x

### 顺序存储结构

**队列的顺序存储**

分配一块连续的存储单元存放队列中的元素，并附设两个指针：

* 队头指针front：指向队头元素
* 队尾指针rear：指向队尾元素的下一个位置

（不同教材对front和rear的定义可能不一样）

```c
#define MaxSize 50
typedef struct{
	ElemType data[MaxSize];	//存放队列元素
	int front, rear;	//两个指针
} SqQueue;
```

初始状态（队空条件）：`Q.front == Q.rear == 0`

进队操作：队不满时，先送值到队尾元素，再将**队尾指针加一**

出队操作：队不空时，先取队头元素，再将**队头指针加一**

不能用`Q.rear==MaxSize`作为队列满的条件。当队列中正好有一个元素并且放在队尾所在的存储单元时，这时为上溢出，但并不是真正的溢出。

**循环队列**

把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针`Q.front=MaxSize-1`后，再前进一个位置就自动到0，这可以用除法取余运算(%)实现。

* 初始时：`Q.front=Q.rear=0`

* 队首指针进1：`Q.front=(Q.front+1)%MaxSize`

* 队尾指针进1：`Q.rear=(Q.rear+1)%MaxSize`

* 队列长度：`(Q.rear+MaxSize-Q.front)%MaxSize`

* 出队入队时：指针按顺时针发方向进1

区分队空队满的方法：

* **牺牲一个存储单元**来区分队空和队满，入队时少用一个队列单元。约定以队头指针在队尾指针的下一个位置作为队满的标志。
  * 队满条件：(Q.rear+1)%MaxSize==Q.front
  * 队空条件：Q.front=Q.rear
  * 队列中元素个数：(Q.rear+MaxSize-Q.front)%MaxSize
* 类型中**增设表示元素个数的数据成员size**，这样空队条件：Q.size==0；队满条件：Q.size==MaxSize
* 类型中**增设tag数据成员**，来区分是队满还是队空。

**循环队列的操作**

* 初始化：

```c
void InitQueue(SqQueue &Q){
	Q.rear=Q.front=0;
}
```

* 判断队空

```c
bool isEmpty(SqQueue Q){
	if(Q.rear==Q.front)		return true;
	else return false;
}
```

* 入队

```c
bool EnQueue(SqQueue &Q, ElemType x){
	if((Q.rear+1)%MaxSize==Q.front)		return false;	//队满则报错
	Q.data[Q.rear]=x;
	Q.rear = (Q.rear+1)%MaxSize;	//队尾指针加一取模
	return true;
}
```

* 出队

```c
bool DeQueue(SqQueue &Q, ElemType &x){
	if (Q.rear == Q.front)	return false;
	x = Q.data[Q.front];
	Q.front = (Q.front + 1) % MaxSize;
	return true;
}
```

### 链式存储结构

**队列的链式存储**

链队列：是一个同时**带有队头指针和队尾指针的单链表**。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（与顺序存储不同）。

```c
typedef struct{		//链式队列结点
	ElemType data;
	struct LinkNode *next;
} LinkNode;
typedef struct{		//链式队列
	LinkNode *front, *rear;	//队头和队尾指针
} LinkQueue;
```

当Q.front==NULL且Q.rear==NULL时，链式队列为空。

出队时首先判断队是否为空，若不空则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点（若该结点为尾结点，则则置两个指针都为NULL）

链式队列通常都设计为**带头结点**的单链表。这样插入和删除操作就统一了。

用单链表表示的链式队列适合于**数据元素变动比较大**的情形，而且不存在队列满且产生溢出的问题。

**链式队列的基本操作**

初始化、判空队、入队、出队。



### 双端队列

允许**两端**都可以进行**入队和出队操作**的队列。元素的逻辑结构仍是线性的，将队列的两端分别称为前端和后端，两端都可以入队和出队。

* 输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入的双端队列。

* 输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除的双端队列。





## 栈和队列的应用

### 栈在括号匹配中的应用

表达式中有圆括号和方括号，有着任意的嵌套顺序，([]\())为正确的格式，[(])为不正确的格式。

使用栈的思想来匹配表达式中的括号：

* 初始设置一个空栈，顺序读入括号
* 若是右括号，则或者使其置于栈顶的最急迫期待得以消解，或是不合法的情况
* 若是左括号，则作为一个新的更急迫的期待压入栈中，自然使得原有的在栈中所有未消解的期待的急迫性降了一级。算法结束时，栈为空，否则括号序列不匹配。

### 栈在表达式求值中的应用

中缀表达式不仅以来运算符的优先级，还要处理括号。后缀表达式的运算符在操作数的后面，后缀表达式中已经考虑了运算符的优先级，没有括号，只有操作数和运算符。

**中缀表达式转化为后缀表达式**的过程：

从左向右开始扫描中缀表达式；

遇到数字时，加入后缀表达式；

遇到运算符时：

* 若为`(`，入栈
* 若为`)`，则依次把栈中的运算符加入后缀表达式，直到出现`(`，从栈中删除`(`；
* 若为除括号外的其他运算符，当其优先级高于除`(`外的栈顶运算符时，直接入栈；否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的，或遇到了一个左括号为止。

当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。

优先级表：

|  (   | *, / | +， - |  )   |
| :--: | :--: | :---: | :--: |
|  1   |  5   |   3   |  6   |



**通过后缀表达式计算值**的过程：顺序扫描表达式的每一项，根据其类型做如下操作：若该项是操作数，则压入栈中；若该项是操作符\<op>，则连续从栈中退出两个操作数Y和X，形成运算指令X\<op>Y，然后将计算结果重新压入栈中。所有项都扫描完后，栈顶存放的就是最终的结果。

### 栈在递归中的应用

递归：在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的。

递归调用过程中，系统为每一层的**返回点、局部变量、传入实参**等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出。

### 队列在层次遍历中的应用

使用栈来层次遍历二叉树：

* 根结点入队；
* 若队空，则结束遍历；否则重复下一步的操作；
* 队列中的第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回上一步。

### 队列在计算机系统中的应用

* 解决主机与外部设备之间速度不匹配的问题，例如打印机的数据缓冲区。
* 解决由多用户引起的资源竞争问题

## 数组和特殊矩阵

### 数组定义

数组是由n个相同类型的数据元素构成的有限序列。每个元素的n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。

数组是线性表的推广，二维数组可视为其元素也是定长线性表的线性表。数组一旦被定义，其维数和界限就不再改变。除结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。

### 数组的存储结构

逻辑意义上的数组可采用计算机语言中的数组数据类型进行存储，一个数组的所有元素在内存中占用了一段连续的存储空间。

对于多维数组，有两种映射方式：**行优先**和**列优先**。

以二维数组为例，按行优先存储的思想：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。

### 矩阵的压缩存储

压缩存储：为多个**值相同**的元素只分配一个存储空间，对**零元素**不分配存储空间。目的是节省存储空间。

特殊矩阵：具有许多**相同矩阵元素或零元素**，并且分布具有一定规律性，例如对角矩阵、对称矩阵、上下三角矩阵。

**对称矩阵**

对于一个n阶方阵，其中的元素可划分为3个部分，即上三角区、主对角线和下三角区。

上下三角区的元素对应相同，因此只存储下三角部分（含对角线）即可，将对称矩阵$A[1...n][1...n]$存放在一维数组$B[n(n+1)/2]$中。

位于元素$a_{i,j}(i\geq j)$前面的元素个数为：

* 第1行：1个元素
* 第2行：2个元素
* ...
* 第i-1行：i-1个元素$(a_{i-1,1},...,a_{i-1,i-1})$
* 第i行：j-1个元素$(a_{i,1},a_{i,2},...,a_{i,j-1})$

则元素$a_{i,j}$在数组B中的下标为：$k=1+2+...+(i-1)+(j-1)=i(i-1)/2+j-1$

上三角区域将i和j对换即可。

**三角矩阵**

下三角矩阵中，上三角区的所有元素均视为同一常量。存储思想为：在存储完下三角区和主对角线上的元素后，紧接着存储对角线上方的常量一次，故可以将下三角矩阵$A[1...n][1...n]$压缩存放在一维数组$B[n(n+1)/2+1]$中。

上三角矩阵同理。

**三对角矩阵**

对于n阶方阵中的任一元素，当$|i-j|>1$时，有$a_{i,j}=0$，称为三对角矩阵。该矩阵所有非零元素都集中在以主对角线为中心的3条对角线的区域，其他区域的元素都为零。

三对角矩阵的压缩存储是将3条对角线上的元素按照行优先方式存储在一维数组B中，且$a_{1,1}$存放在B[0]处。

元素$a_{i,j}$在一维数组B中存放的下标为$k=2i+j-3$。

### 稀疏矩阵

矩阵中非零元素的个数t，相对矩阵元素的个数s来说非常少，即s>>t的矩阵称为稀疏矩阵。

常规方法存储稀疏矩阵相当浪费空间，因此仅存储**非零元素以及它所在的行和列**，构成一个**三元组（行标，列标，值）**，然后按照某种规律存储这些三元组。稀疏矩阵压缩存储后便失去了其随机存取特性。

三元组可以用数组或十字链表法存储。

