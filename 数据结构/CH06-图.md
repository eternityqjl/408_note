## 图的基本概念

### 定义

图G是由顶点集V和边集E组成，记作$G=(V,E)$，其中V(G)表示图中顶点的有限非空集；E(G)表示图G中顶点之间的关系。

图不可是空图。图的顶点集V一定非空，但边集可以为空。

**有向图和无向图**



**简单图、多重图**



**完全图**

分为完全图（无向）、有向完全图



**子图**





**连通、连通图和连通分量**

无向图中的概念：任意两个顶点之间都存在路径。连通分量：无向图中的极大连通子图



**强连通图、强连通分量**

有向图任何一对顶点相互之间都有路径。强连通分量：有向图的极大连通子图



**生成树、生成森林**

连通图的生成树：包含图中全部顶点的极小连通子图。

非连通图中的连通分量的生成树构成了非连通图的生成森林。



**顶点的度、入度和出度**

无向图中，顶点v的度指的是依附于顶点v的边的条数。无向图的全部顶点的度的和等于边数的2倍。

有向图顶点v的度分为入度和出度，入度是以顶点v为终点的有向边的数目；出度是以顶点v为起点的有向边的数目。

**边的权和网**

带权图。



**稠密图、稀疏图**

一个相对概念，把图G满足$|E|<|V|\log|V|$时称为稀疏图。



**路径、路径长度、回路**

路径长度：路径上边的数目

若一个图有n个顶点，并且有大于n-1条边，则此图一定有环。



**简单路径、简单回路**

路径序列中顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点，其余顶点不重复出现的回路称为简单回路。



**距离**

两顶点间的距离：两顶点间的最短路径



**有向树**

一个顶点的入度为0、其余顶点的入度均为1的有向图。



## 图的存储和基本操作

图的存储要完整地反映顶点集和边集的信息。

### 邻接矩阵法

用一个**一维数组**存储图中**顶点**的信息，用一个**二维数组**存储图中**边**的信息。存储顶点之间邻接关系的二维数组称为邻接矩阵。

```c
typedef MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct {
	VertexType Vex[MaxVertexNum];
	EdgeType Edge[MaxVertexNum][MaxVertexNum];
	int vexnum, arcnum;
} MGraph;
```



### 邻接表法

当一个图为**稀疏矩阵**时，使用邻接矩阵法会浪费大量空间，而邻接表法结合了顺序存储和链式存储，减少了这种不必要的浪费。

* 边表：存储一个顶点连接的所有顶点所依附的边，为链式存储

* 顶点表：边表的头指针和顶点数据采用顺序存储

```c
#define MaxVertexNum 100
typedef struct ArcNode {	//边表结点
	int adjvex;		//该弧指向的顶点的位置
	struct ArcNode *next;	//指向下一条弧的指针
	//InfoType info;	//网的边权值
} ArcNode;
typedef struct Vnode {	//顶点表结点
	VertexType data;	//顶点信息
	ArcNode *first;	//头指针
} VNode, AdjList[MaxVertexNum];
typedef struct {	
	AdjList vertices;	//邻接表
	int vexnum, arcnum;	//顶点数和弧数
} ALGraph;	//ALGraph是以邻接表存储的图类型
```



### 十字链表

十字链表是**有向图**的一种**链式**存储结构。在十字链表中，对应于有向图中的**每条弧**有一个结点，对应于**每个顶点**也有一个结点。

* 弧结点：

| tailvex | headvex | hlink | tlink | info |
| :-----: | :-----: | :---: | :---: | :--: |



* 顶点结点：

| data | firstin | firstout |
| :--: | :-----: | :------: |





十字链表中，既容易找到以一个顶点为尾的弧，又容易找到以一个结点为头的弧。



### 邻接多重表

每条边和每个顶点各用一个结点表示。

邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。





### 图的基本操作

图的基本操作独立于图的存储结构。对于不同存储方式，操作算法的具体实现有着不同的性能。

基本操作主要包括：

* 判断图G中是否存在边(x,y)
* 列出图G中与结点x邻接的边
* 在图中插入顶点x
* 从图中删除顶点x

。。。。

## 图的遍历

图的遍历指从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中所有顶点访问一次且仅访问一次

图中的任一顶点都可能与其他顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到了该顶点。为避免同一顶点被多次访问，在遍历图的过程中，可以设置一个辅助数组visited[]记录下已经访问过的顶点。

### 广度优先搜索BFS

Breadth-First-Search，BFS，类似于二叉树的层序遍历算法。从起始顶点v出发，一次访问v的各个未访问过的邻接顶点$w_1,w_2,...,w_i$，然后依次访问这些邻接结点的邻接结点，直到图中所有顶点都被访问过为止。如果此时图中尚有未访问过的顶点，则另选图中一个未访问过的顶点作为起始点，重复上述过程，直到所有结点都被访问。

为了实现BFS的逐层访问，必须借助一个**辅助队列**，来记忆正在访问的顶点的下一层顶点。

该算法的伪代码如下：

```
```





**BFS算法性能分析**

无论图采用邻接表或邻接矩阵的存储方式，BFS都需要借助辅助队列Q，n个顶点均需要入队依次，最坏的情况下，所有顶点都在队列中，**空间复杂度**为$O(|V|)$。

采用**邻接表**存储，每个顶点均需搜索（入队）一次，时间复杂度为$O(|V|)$，在搜索任一顶点的邻接点时，每条边至少访问一次，时间复杂度为$O(|E|)$，**总时间复杂度为**$O(|E|+|V|)$。采用**邻接矩阵**存储时，同样每个顶点均需搜索（入队）一次，时间复杂度为$O(|V|)$，在搜索任一顶点的邻接点所需的时间为$O(|V|)$，所以**总时间复杂度为**$O(|V|^2)$。

**BFS求解单源最短路径的问题**

在遍历的过程中**顺便求解**两顶点间的最短路径。以**其中一个顶点为头结点**进行广度优先搜索遍历。



**广度优先生成树**

给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的；由于邻接表存储方式不唯一，其广度优先生成树不唯一。





### 深度优先搜索DFS

类似于**树的先序遍历**。算法思想为：首先访问图中某一起始顶点v，由v出发访问与v邻接且未访问过的任一顶点$w_1$，然后继续访问与$w_1$邻接的任意顶点$w_2$，重复以上过程，直到不能继续访问下去时，依次退回最近被访问过的顶点，若它还有其他邻接顶点未被访问，从该点开始重复上述过程，直到图中所有顶点都被访问为止。

该算法采用递归形式实现十分简洁：

```c
bool visited[MAX_VERTEX_NUM];	//访问标记数组
void DFSTraverse(Graph G) {
	for (v = 0; v < G.vexnum; ++v)
		visited[v] = false;
	for (v = 0; v < G.vexnum; ++v)		//需要该循环的原因是这个图不一定是连通图
		if(!visited[v])	 DFS(G, v);
}
void DFS(Graph G, int v) {
	visit(v);
	visited[v] = true;
	for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
		if(!visited[w])	 DFS(G, w);
}
```

**DFS的性能分析**

该算法是一个递归算法，需要一个递归工作栈，因此空间复杂度为$O(|V|)$。

时间复杂度与**存储结构**有关，遍历图的实质是对每个顶点的邻接顶点的查找过程。用邻接矩阵存储时，总时间复杂度为$O(|V|^2)$；用邻接表存储时，总时间复杂度为$O(|E|+|V|)$

**深度优先的生成树和生成森林**







## 图的应用

### 最小生成树

一个连通图的**生成树**包含图的**所有顶点以及尽可能少的边**。对于生成树来说，砍去其一条边就会变成非连通图；若增加一条边，图中就会形成一条回路。

一个带权连通无向图$G=(V,E)$，生成树不同，每棵树的权也可能不同。设R为G的所有生成树的集合，若T为R中边的**权值之和最小的树**，那么称T为G的**最小生成树**（MST）。

* 最小生成树可能不唯一。
* 最小生成树的边的权值之和唯一。
* 最小生成树的边数为顶点数减1。

最小生成树的构造大多利用以下**性质**：假设$G=(V,E)$是一个带权连通无向图，U是顶点集V的一个非空子集，若(u,v)是一条具有最小权值的边，其中$u\in U,v\in V-U$，则存必在一棵包含边(u,v)的最小生成树。

通用最小生成树的实现算法：

```
GENERIC_MST(G) {
	T = NULL;
	while T未形成一棵树;
		do 找到一条最小代价边(u,v)并且加入T后不产生回路;
			将改变加入T;
}
```

通用算法每次加入一条边以逐渐形成一棵生成树。

**Prim算法**

初始时从图中任取一个顶点加入树T，此时树中仅含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后树T的顶点和边数都增加1.以此类推，直到图中所有顶点都并入树T，得到的就是最小生成树T。

简单实现如下：

```
```

Prim算法的时间复杂度为$O(|V|^2)$，不依赖于边数E，因此其适用于求解**边稠密**的图的最小生成树。

**Kruskal算法**

该算法是一种**按权值的递增次序**选择合适的边来构造最小生成树的方法。

初始时为只有n个顶点而无边的非连通图T，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选择当前未被选取过且权值最小的边，若该边依附的顶点落在**不同连通分量**上，则将该边加入T，否则舍弃此边选择下一条权值最小的边。以此类推，直到所有顶点都在一个连通分量上。

简单实现：

```

```

### 最短路径

当图是带权图时，把从一个顶点$v_0$到图中其余任意一个顶点$v_i$的一条路径所经过边上权值之和定义为该路径的**带权路径长度**，把带权路径长度**最短**的那条路径称为最短路径。

求解最短路径的算法通常依赖于一种性质：两点之间的最短路径也包含了路径上其他顶点间的最短路径。

**Dijkstra算法求单源最短路径问题**

迪杰斯特拉算法是用来求**单源**最短路径，即图中某一顶点到其他各顶点的最短路径。

该算法会设置一个**集合S**记录**已求得的最短路径的顶点**，初始时把源点$v_0$放入S，集合S每并入一个新顶点$v_i$，都要修改源点$v_0$到集合V-S中顶点当前的最短路径长度值。

另外构造过程中还设置了两个辅助数组：

* dist[]：记录从$v_0$到其他各顶点的**当前最短路径**；初态为：若从$v_0$到$v_i$有弧，则dist[i]为弧上的权值；否则置dist[i]为$\infin$。
* path[]：path[i]表示从源点到顶点i之间的**最短路径的前驱结点**。算法结束时可以根据其值回溯得到源点$v_0$到顶点$v_i$的最短路径。

Dijkstra算法的步骤如下：（arcs\[i][j]表示有向边<i,j>的权值）

* 初始化：集合S初始化为$\{0\}$，dist[i]的初始值arcs\[0][i]

* 从顶点集合V-S中选出$v_j$，满足$dsit[j]=Min\{\text{dist}[i]| v_i\in V-S\}$，$v_j$就是当前求得的一条从$v_0$出发的最短路径的的终点，令$S=S\or \{j\}$

* 修改从$v_0$出发到集合V-S上任一顶点$v_k$的最短路径长度，若：

  dist[j]+arcs\[j][k]<dist[k]，则更新dist[k]=dist[j]+arcs\[j][k]

* 重复上面中间的两部，操作共n-1次，直到所有顶点都包含在S中

使用邻接矩阵表示时，时间复杂度为$O(|V|^2)$；使用带权的邻接表时，虽然修改dist[]的时间减少，但是在dist[]中选择最小分量的时间不变，时间复杂度仍为$O(|V|^2)$

该算法不适用于边上带有负权值的情况。

**Floyd算法求各顶点之家最短路径问题**

弗洛伊德算法用来求**每对顶点间**的最短路径。

递推产生一个n阶方阵序列$A^{(-1)},A^{(0)},...,A^{(k)},A^{(n-1)}$，其中$A^{(k)}[i][j]$表示从顶点$v_i$到顶点$v_j$的路径长度，k表示绕行第k个顶点的运算步骤。初始时对于任意两个顶点，若他们之间存在边，则此边上的权值最为他们之间的最短路径；若它们之间不存在有向边，则以$\infin$作为它们之间的最短路径。以后逐步尝试在原路径中加入顶点k作为中间顶点，若增加顶点后，得到的路径比原来的路径减少，则以新路径代替原路径。



Floyd算法的时间复杂度为$O(|V|^3)$。



### 有向无环图描述表达式

有向无环图：一个有向图不存在环路，简称**DAG图**。

有向无环图可以用来描述含有**公共子式**的表达式，能够实现对公共子式的共享，从而节省存储空间。

### 拓扑排序

AOV网：**顶点表示活动的网络**；用DAG图表示一个工程，顶点表示活动，有向边$<V_i,V_j>$表示活动$V_i$必须先于$V_j$进行的关系。

拓扑排序：由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑序列：

* 每个顶点出现且仅**出现一次**
* 若顶点A出现在顶点B的前面，则**不出现由B到A的路径**

每个AOV网都有一个或多个拓扑排序序列。

对一个AOV网进行拓扑排序的步骤：

* 从AOV网中选择一个没有前驱的顶点并输出
* 从网中删除该顶点和所有以它为起点的有向边
* 重复以上两步，直到当前的AOV网为空或当前网中不存在无前驱的顶点为止，后一种情况说明有向图中必然存在环。



### 关键路径

AOE网：用**边表示活动的网络**；以顶点表示事件，以有向边表示活动，以**边上的权值**表示完成该活动的**开销**（例如完成活动所需时间）。

AOE网和AOV网都是有向无环图，不同之处在于其边和顶点表示的含义不同，AOE网中的边有权值；AOV网中的边无权值，仅表示前后关系。

AOE网具有的性质：

* 只有某顶点代表的事情发生后，从该顶点出发的各有向边所代表的活动才能开始
* 只有进入某顶点的各有向边所代表的活动都已结束时，该顶点代表的事件才能发生

AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），代表整个工程的开始；网中也仅存在一个出度为0的顶点，称为结束顶点（汇点），表示整个工程的结束。

从源点到汇点的所有路径中，具有**最大路径长度**的路径称为关键路径，关键路径上的活动称为关键活动。只要找到了关键活动就找到了关键路径。

一些寻找关键活动是用到的参量：

**事件$v_k$的最早发生时间$ve(k)$**

只从源点$v_1$到顶点$v_k$的最长路径长度。时间$v_k$的最早发生时间代表了所有从$v_k$开始的活动能够开工的最早时间。



**事件$v_k$的最迟发生时间$vl(k)$**

在不推迟整个工程完成的前提下，即保证后继时间$v_j$在最迟发生时间$vl(j)$能够发生时，该事件最迟必须发生的时间。

可以用以下公式进行计算：

* $vl(汇点)=ve(汇点)$
* $vl(k)=\text{Min}\{vl(j)-\text{Weight}(v_k,v_j)\}$，$v_k$为$v_j$的任意前驱

**活动$a_i$的最早开始时间$e(i)$**



**活动$a_i$的最早开始时间$l(i)$**

