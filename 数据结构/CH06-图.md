## 图的基本概念

### 定义

图G是由顶点集V和边集E组成，记作$G=(V,E)$，其中V(G)表示图中顶点的有限非空集；E(G)表示图G中顶点之间的关系。

图不可是空图。图的顶点集V一定非空，但边集可以为空。

**有向图和无向图**



**简单图、多重图**



**完全图**

分为完全图（无向）、有向完全图



**子图**





**连通、连通图和连通分量**

无向图中的概念：任意两个顶点之间都存在路径。连通分量：无向图中的极大连通子图



**强连通图、强连通分量**

有向图任何一对顶点相互之间都有路径。强连通分量：有向图的极大连通子图



**生成树、生成森林**

连通图的生成树：包含图中全部顶点的极小连通子图。

非连通图中的连通分量的生成树构成了非连通图的生成森林。



**顶点的度、入度和出度**





**边的权和网**





**稠密图、稀疏图**

一个相对概念，把图G满足$|E|<|V|\log|V|$时称为稀疏图。



**路径、路径长度、回路**

路径长度：路径上边的数目

若一个图有n个顶点，并且有大于n-1条边，则此图一定有环。



**简单路径、简单回路**





**距离**

两顶点间的距离：两顶点间的最短路径



**有向树**

一个顶点的入度为0、其余顶点的入度均为1的有向图。



## 图的存储和基本操作

图的存储要完整地反映顶点集和边集的信息。

### 邻接矩阵法

用一个**一维数组**存储图中**顶点**的信息，用一个**二维数组**存储图中**边**的信息。存储顶点之间邻接关系的二维数组称为邻接矩阵。

```c
typedef MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct {
	VertexType Vex[MaxVertexNum];
	EdgeType Edge[MaxVertexNum][MaxVertexNum];
	int vexnum, arcnum;
} MGraph;
```



### 邻接表法

当一个图为稀疏矩阵时，使用邻接矩阵法会浪费大量空间，而邻接表法结合了顺序存储和链式存储，减少了这种不必要的浪费。

* 边表：存储一个顶点连接的所有顶点所依附的边，为链式存储

* 顶点表：边表的头指针和顶点数据采用顺序存储

```c
#define MaxVertexNum 100
typedef struct ArcNode {	//边表结点
	int adjvex;		//该弧指向的顶点的位置
	struct ArcNode *next;	//指向下一条弧的指针
	//InfoType info;	//网的边权值
} ArcNode;
typedef struct Vnode {	//顶点表结点
	VertexType data;	//顶点信息
	ArcNode *first;	//头指针
} VNode, AdjList[MaxVertexNum];
typedef struct {	
	AdjList vertices;	//邻接表
	int vexnum, arcnum;	//顶点数和弧数
} ALGraph;	//ALGraph是以邻接表存储的图类型
```



### 十字链表

十字链表是**有向图**的一种**链式**存储结构。在十字链表中，对应于有向图中的**每条弧**有一个结点，对应于**每个顶点**也有一个结点。

* 弧结点：

| tailvex | headvex | hlink | tlink | info |
| :-----: | :-----: | :---: | :---: | :--: |



* 顶点结点：

| data | firstin | firstout |
| :--: | :-----: | :------: |





十字链表中，既容易找到以一个顶点为尾的弧，又容易找到以一个结点为头的弧。



### 邻接多重表

每条边和每个顶点各用一个结点表示。

邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。





### 图的基本操作

图的基本操作独立于图的存储结构。对于不同存储方式，操作算法的具体实现有着不同的性能。

基本操作主要包括：

* 判断图G中是否存在边(x,y)
* 列出图G中与结点x邻接的边
* 在图中插入顶点x
* 从图中删除顶点x

。。。。

## 图的遍历

图的遍历指从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中所有顶点访问一次且仅访问一次

图中的任一顶点都可能与其他顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到了该顶点。为避免同一顶点被多次访问，在遍历图的过程中，可以设置一个辅助数组visited[]记录下已经访问过的顶点。

### 广度优先搜索BFS

Breadth-First-Search，BFS，类似于二叉树的层序遍历算法。从起始顶点v出发，一次访问v的各个未访问过的邻接顶点$w_1,w_2,...,w_i$，然后依次访问这些邻接结点的邻接结点，直到图中所有顶点都被访问过为止。如果此时图中尚有未访问过的顶点，则另选图中一个未访问过的顶点作为起始点，重复上述过程，直到所有结点都被访问。

为了是新BFS的逐层访问，必须借助一个辅助队列，来记忆正在访问的顶点的下一层顶点。

该算法的伪代码如下：





**BFS算法性能分析**

无论图采用邻接表或邻接矩阵的存储方式，BFS都需要借助辅助队列Q，n个顶点均需要入队依次，最坏的情况下，所有顶点都在队列中，**空间复杂度**为$O(|V|)$。

采用**邻接表**存储，每个顶点均需搜索（入队）一次，时间复杂度为$O(|V|)$，在搜索任一顶点的邻接点时，每条边至少访问一次，时间复杂度为$O(|E|)$，**总时间复杂度为**$O(|E|+|V|)$。采用**邻接矩阵**存储时，同样每个顶点均需搜索（入队）一次，时间复杂度为$O(|V|)$，在搜索任一顶点的邻接点所需的时间为$O(|V|)$，所以**总时间复杂度为**$O(|V|^2)$。

**BFS求解单源最短路径的问题**

在遍历的过程中顺便求解两顶点间的最短路径。以其中一个顶点为头结点进行广度优先搜索遍历。



**广度优先生成树**

给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的；由于邻接表存储方式不唯一，其广度优先生成树不唯一。





### 深度优先搜索DFS

类似于树的先序遍历。算法思想为：首先访问图中某一起始顶点v，由v出发访问与v邻接且未访问过的任一顶点$w_1$，然后继续访问与$w_1$邻接的任意顶点$w_2$，重复以上过程，直到不能继续访问下去时，依次退回最近被访问过的顶点，若它还有其他邻接顶点未被访问，从该点开始重复上述过程，直到图中所有顶点都被访问为止。

该算法采用递归形式实现十分简洁：

```c
bool visited[MAX_VERTEX_NUM];	//访问标记数组
void DFSTraverse(Graph G) {
	for (v = 0; v < G.vexnum; ++v)
		visited[v] = false;
	for (v = 0; v < G.vexnum; ++v)		//需要该循环的原因时这个图不一定是连通图
		if(!visited[v])	 DFS(G, v);
}
void DFS(Graph G, int v) {
	visit(v);
	visited[v] = true;
	for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
		if(!visited[w])	 DFS(G, w);
}
```

**DFS的性能分析**

该算法是一个递归算法，需要一个递归工作栈，因此空间复杂度为$O(|V|)$。

时间复杂度与**存储结构**有关，遍历图的实质是对每个顶点的邻接顶点的查找过程。用邻接矩阵存储时，总时间复杂度为$O(|V|^2)$；用邻接表存储时，总时间复杂度为$O(|E|+|V|)$

**深度优先的生成树和生成森林**







## 图的应用

### 最小生成树

一个连通图的**生成树**包含图的**所有顶点以及尽可能少的边**。对于生成树来说，砍去其一条边就会变成非连通图；若增加一条边，图中就会形成一条回路。

一个带权连通无向图$G=(V,E)$，生成树不同，每棵树的权也可能不同。设R为G的所有生成树的集合，若T为R中边的**权值之和最小的树**，那么称T为G的**最小生成树**（MST）。

* 最小生成树可能不唯一。
* 最小生成树的边的权值之和唯一。
* 最小生成树的边数为定点数减1。

最小生成树的构造大多利用以下**性质**：假设$G=(V,E)$是一个带权连通无向图，U是顶点集V的一个非空子集，若(u,v)是一条具有最小权值的边，其中$u\in U,v\in V-U$，则比存在一棵包含边(u,v)的最小生成树。

通用最小生成树的实现算法：

```
GENERIC_MST(G) {
	T = NULL;
	while T未形成一棵树;
		do 找到一条最小代价边(u,v)并且加入T后不产生回路;
			将改变加入T;
}
```

**Prim算法**





**Kruskal算法**









### 最短路径

当图是带权图时，把从一个顶点$v_0$到图中其余任意一个顶点$v_i$的一条路径所经过边上权值之和定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。

求解最短路径的算法通常伊朗与一种性质：两点之间的最短路径也包含了路径上其他顶点间的最短路径。

**Dijkstra算法求单源最短路径问题**







**Floyd算法求各顶点之家最短路径问题**









### 有向无环图描述表达式





### 拓扑排序





### 关键路径



