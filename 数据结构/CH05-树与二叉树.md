## 树的基本概念

### 定义





### 基本术语

* 结点的度：树中一个结点的孩子个数

* 树的度：树中结点的最大度数
* 结点的深度、高度、层次：
  * 层次：从树根开始定义，根结点为第1层，其子结点为第2层
  * 深度：从根结点开始自顶向下逐层累加
  * 高度：从叶结点开始自底向上逐层累加

### 性质





## 二叉树的概念

### 定义及主要特性

**定义**

每个结点至多只有两棵子树（即不存在度大于2的结点），并且二叉树的子树有左右之分，次序不能颠倒。

二叉树与度为2的有序树的区别：

* 度为2的树至少有3个结点，而二叉树可以为空
* 度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，如果某个结点只有一个孩子，则这个孩子就无须区分其左右次序；而二叉树无论海子叔是否为2，均需要确定其左右次序。

**几个特殊二叉树**

* 满二叉树：一颗高度为h，且含有$2^h-1$个结点的二叉树。即树中的每层都含有最多的结点。
* 完全二叉树：高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应时，成为完全二叉树。
  * 若有度为1的结点，则只可能有一个，且该结点只有左孩子没有右孩子
* 二叉排序树：左子树上所有结点的关键字均小于根结点的关键字，右子树上的所有结点的关键字均大于根结点的关键字；左右子树又各自是一颗二叉排序树。
* 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1.

**性质**

* 非空二叉树上叶子结点数等于度为2的结点数加1





### 存储结构

**顺序存储**

使用一组地址连续的存储单元**自上而下、自左至右**存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标为i-1的分量中。

**完全二叉树和满二叉树**采用顺序存储比较适合，树中结点的序号可以唯一地反映结点之间的逻辑关系，既能节省空间，又能利用数组元素下标值确定结点在二叉树中的位置。

对于一般二叉树，例如深度较深、结点较少的二叉树，使用顺序存储比较浪费空间，一般采用链式存储。

**链式存储**

用链表结点来存储二叉树中的每个结点。二叉链表一般包括3个域：数据域data、左指针域lchild、右指针域rchild。

```c
typedef struct BiTNode {
	ElemType data;	//数据域
	struct BiTNode *lchild, *rchild;	//左右孩子指针
}BiTNode, *BiTree;
```



## 二叉树的遍历和线索二叉树

### 二叉树的遍历

二叉树遍历是指按照某条搜索路径**访问树中每个结点**，使得每个结点均被访问一次，而且仅被访问一次。要找到一种规律，使得二叉树上的结点能排列在一个线性队列上，进而便于遍历。

常见的遍历次序有先序、中序、后序。序指的是**根结点**在何时被访问。

**先序遍历**

若二叉树为空，则什么也不做；否则：

* 访问根节点；
* 先序遍历左子树；
* 先序遍历右子树；

```c
void PreOrder(BiTree T) {
	if (T != NULL) {
		visit(T);	//访问根节点
		PreOrder(T->lchild);	//递归遍历左子树
		PreOrder(T->rchild);	//递归遍历右子树
	}
}
```

**中序遍历**

若二叉树为空，则什么也不做；否则：

* 中序遍历左子树；
* 访问根节点；
* 中序遍历右子树；

```c
void InOrder(BiTree T) {
	if (T != NULL) {
		InOrder(T->lchild);	//递归遍历左子树
		visit(T);	//访问根节点
		InOrder(T->rchild);	//递归遍历右子树
	}
}
```

**后序遍历**

若二叉树为空，则什么也不做；否则：

* 后序遍历左子树；
* 后序遍历右子树；
* 访问根节点。

```c
void PostOrder(BiTree T) {
	if (T != NULL)
    {
        PostOrder(T->lchild);	//递归遍历左子树
        PostOrder(T->rchild);	//递归遍历右子树
        visit(T);	//访问根节点
    }
}
```

三种遍历算法中递归遍历左右子树的顺序都是固定的，只是访问根节点的顺序不同。无论采用哪种遍历方法，每个结点都只访问一次，故时间复杂度为O(n)。递归工作栈的深度恰好为树的深度，所以在最坏的情况下二叉树是有n个结点且深度为的单支树，空间复杂度为O(n).

**递归算法和非递归算法的转换**

中序遍历的非递归算法：

```c
void InOrder2(BiTree T) {
    InitStack(S); BiTree p = T;
    while (p || !IsEmpty(S)) {	//栈不为空或p不空时循环
        if(p) {	//一直向左遍历
            Push(S, p);	//将当前结点入栈
            p = p->lchild;	//左孩子不空，一直向左走
        }
        else {	//出栈，并转向出栈结点的右子树
            Pop(S, p); visit(p);	//栈顶元素出栈，访问出栈结点
            p = p->rchild;	//向右子树走，p赋值为当前结点的右孩子
        }	//返回while循环继续进行if-else
    }
}
```

先序遍历的非递归算法：

```c
void PreOrder2(BiTree T) {
    InitStack(S); BiTree p = T;
    while (p || !IsEmpty(S)) {	//栈不为空或p不空时循环
    	if (p) {
            visit(p); Push(S, p);	//访问当前结点并入栈
            p = p->lchild;
        }
        else {
            Pop(S, p);
            p = p->rchild;
        }
    }
}
```

后序遍历要保证左孩子和右孩子都已经被访问并且左孩子在右孩子前访问才能访问根节点。思想为：从根节点开始，将其入栈，然后沿着左子树一直往下搜索，直到搜索到没有左孩子的结点，此时还不能出栈并访问，如果其有右子树，还要按照相同的规则对右子树进行处理，直到上述操作无法进行。栈顶元素想要被出栈访问，要么右子树为空，要么右子树刚被访问完。



**层次遍历**

按照1,2,3,4,...的层次顺序，对二叉树中的各个结点进行访问。

进行层次遍历需要借助一个**队列**。先将二叉树的根节点入队，然后出队，访问出队结点，若其有左子树，则将左子树根结点入队；若其有右子树，则将右子树根节点入队。然后出队，访问出队结点....以此类推，直到队列为空。

```c
void LevelOrder(BiTree T) {
    InitQueue(Q);
    BiTree p;
    EnQueue(Q, T);	//将根节点入队
    while (!IsEmpty(Q)) {
        DeQueue(Q, p);
        visit(p);
        if(p->lchild != NULL)
            EnQueue(Q, p->lchild);
        if(p->rchild != NULL)
            EnQueue(Q, p->rchild);
    }
}
```

**由遍历序列构造二叉树**

* 由二叉树的**先序序列和中序序列**可以唯一地确定一颗二叉树：

在先序遍历序列中，第一个结点一定是二叉树的**根结点**；中序遍历中，根结点必然将中序序列**分割为两个子序列**，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列；在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点时右子树的根结点。如此递归下去，便能唯一确定一颗二叉树。

* 同理，由二叉树的**后序序列和中序序列**也可以唯一地确定一棵二叉树：

后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割为两个子序列，然后继续递归。

* 只知道先序和后序序列无法确定一棵二叉树。

见书上的例题。

### 线索二叉树

**概念**

传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。这里设想用叶结点或度为1的结点的**空指针**来存放指向其**前驱或后继**的指针。这样就可以像遍历单链表一样方便地遍历二叉树。引入线索二叉树是为了**加快查找结点前驱和后继**的速度。

规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。另外还需增加两个编制域标识指针域是指向左(右)孩子还是指向前驱(后继).

线索二叉树的结点结构：

| lchild | ltag | data | rtag | rchlid |
| :----: | :--: | :--: | :--: | :----: |

标志域的含义：

ltag：0，lchild域指向结点的左孩子；1，lchild指向结点的前驱

rtag：0，rchild域指向结点的左孩子；1，rchild指向结点的前驱

线索二叉树的存储结构描述如下：

```c
typedef struct ThreadNode {
	ElemType data;	//数据元素
	struct ThreadNode *lchild, *rchild;	//左右孩子指针
	int ltag, rtag;		//左右线索标志
} ThreadNode, *ThreadTree;
```

**中序线索二叉树的构造**

二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。前驱或后继的信息只有在遍历时才能得到，因此线索化实质上就是遍历一次二叉树。

中序线索二叉树的建立：附设指针pre指向刚刚访问过的结点，指针p指向正在访问的结点，即pre指向p的前驱。中序遍历的过程中，检查p的左指针是否为空，若为空就将其指向pre；检查pre的右指针是否为空，若为空则将其指向p。

```c
void InThread(ThreadTree &p, ThreadTree &pre) {
	if (p != NULL) {
        InThread(p->lchild, pre);	//递归，线索化左子树
        if (p->lchild == NULL) {
            p->lchild = pre;
            p->ltag = 1;
        }
        if (pre != NULL && pre->rchild == NULL) {
            pre->rchild = p;	//建立前驱结点的后继线索
            pre->rtag = 1;
        }
        pre = p;
        InThread(p->rchild, pre);
    }//if(p!=NULL)
}
```

通过中序遍历建立中序线索二叉树的主过程算法：

```c
void CreatInThread(ThreadTree T) {
	ThreadTree pre = NULL;
    if (T != NULL) {	//非空二叉树，线索化
        InThread(T, pre);	//线索化二叉树
        pre->rchild = NULL;	//处理遍历后的最后一个结点
        pre->rtag = 1;
    }
}
```

另外为了方便，可以在二叉树的线索链表上添加一个**头结点**Head，令其**lchild域**的指针指向二叉树的**根结点**，其**rchild域**的指针指向中序遍历时访问的**最后一个结点**；令二叉树中序序列中的**第一个结点的lchild域**和**最后一个结点的rchild域**指针均指向**头结点**。这就好比为二叉树建立了一个双线线索链表，方便从前向后或从后向前对线索二叉树进行遍历。

**中序线索二叉树的遍历**

中序线索二叉树隐含了线索二叉树的前驱和后继信息。对其遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。找结点后继的规律为：若其右标志为1，则右链为线索，指示其后继；否则遍历右子树中第一个访问的结点（即右子树中最左下的结点）为其后继。

* 求中序线索二叉树中中序序列下的第一个结点：

```c
ThreadNode *Firstnode(ThreadNode *p) {
	while (p->ltag == 0)
        p = p->lchild;	//最左下结点
	return p;
}
```

* 求结点p在中序序列下的后继：

```c
ThreadNode *Nextnode(ThreadNode *p) {
	if (p->rtag == 0)
        return Firstnode(p->rchild);
	else 
        return p->rchild;
}
```

利用以上的两个算法，可以得到不含头结点的中序线索二叉树的**中序遍历**的算法：

```c
void Inorder (ThreadNode *T) {
	for (ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p))
		visit(p);
}
```

**先序线索二叉树和后序线索二叉树**

建立先序和后序线索二叉树的代码类似于中序线索二叉树，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。

在先序线索二叉树中找结点后继：

* 如果有左孩子，则左孩子就是后继；
* 如果无左孩子，有右孩子，则右孩子就是其后继；
* 如果为叶结点，则右链域直接指示了结点的后继。

在后序线索二叉树中找结点后继：

* 若结点x是根结点，则后继为空；
* 若结点x是双亲的右孩子，或是双亲的左孩子且双亲没有右子树，则后继为双亲；
* 若结点x是双亲的左孩子且双亲有右子树，则后继为双亲右子树上按后序遍历列出的第一个结点。

## 树、森林

### 树的存储结构

可以采用**顺序或链式**存储结构，必须要反映出树种各个结点之间的逻辑关系。

**双亲表示法**

采用连续空间存储每个结点，同时在每个结点中增设一个伪指针，指示其**双亲结点在数组中的位置**。根节点下标为0，其伪指针域为-1.

存储结构描述如下：

```c
#define MAX_TREE_SIZE 100	//树中最多结点数
typedef struct {	//树的结点的定义
	ElemType data;	//数据元素
	int parent;	//双亲位置域
} PTNode;
typedef struct {	//树类型的定义
	PTNode nodes[MAX_TREE_SIZE];	//双亲表式
	int n;	//结点数
} PTree;
```

该结构利用了每个结点（除根节点）只有一个双亲的性质，可以很快地得到每个结点的双亲，但是求结点的孩子时需要遍历整个结构。

>树的顺序存储结构与二叉树的顺序存储结构有些不同。书的顺序存储中，数组下标代表结点的编号，下表中存储的内容指示了结点之间的关系；二叉树的顺序存储中，数组的下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。

**孩子表示法**

这种方法将每个结点的孩子都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表，叶子结点的孩子链表为空。

这种存储方式**寻找子女**的操作很直接，而寻找双亲需要遍历n个结点中孩子链表指针域指向的n个孩子链表。

**孩子兄弟表示法**

又称**二叉树表示法**，即以二叉链表作为树的存储结构。每个结点包括三部分内容：结点值、指向结点的**第一个孩子**的指针以及指向结点**下一个兄弟结点**的指针。沿此域可以找到结点的所有兄弟结点。

该方法的存储结构描述如下：

```c
typedef struct CSNode {
	ElemType data;
	struct CSNode *firstchild, *nextsibling;
}CSNode, *CSTree;
```

此方法的最大优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子。

### 树、森林与二叉树的转换

二叉树和树都可以用**二叉链表**作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的对应关系，即给定一棵树，可以找到**唯一的一个二叉树与之对应**。

树转换为二叉树的规则：每个结点左指针指向它的**第一个孩子**，右指针指向它在树中**相邻的右兄弟**，这个规则称为**左孩子右兄弟**。

将森林转换为二叉树的规则与树类似，先将森林中的每一棵树转换为二叉树，由于**任何一棵树**对应的**二叉树的右子树必为空**，若把第二棵树的二叉树视为第一颗二叉树树根的右兄弟，将第三棵树对应的二叉树当作第二课二叉树树根的右兄弟，以此类推，就可以将森林转换为二叉树。

### 树和森林的遍历

用某种方式访问树中的每个结点。

* 先根遍历：先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍然遵循**先根后子树**的规则。其遍历序列与该树对应的二叉树的**先序序列**相同。
* 后根遍历：先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循**先子树后根**的规则。其遍历序列与该树对应的二叉树的**中序序列**相同。

按照树和森林相互递归的定义，可得到森林的两种遍历方法：

* 先序遍历森林：
  * 访问呢森林中第一棵树的根结点
  * 先序遍历第一棵树中根结点的子树森林
  * 先序遍历除去第一棵树之后剩余树构成的森林
* 中序遍历森林：
  * 中序遍历森林中第一棵树的根结点的子树森林
  * 访问第一棵树的根结点
  * 中序遍历除去第一棵树之后剩余的树构成的森林

### 树的应用——并查集





## 树与二叉树的应用

### 二叉排序树（BST）

**定义**

也称二叉查找树，是一个具有以下特性的二叉树：

* 若左子树非空，则**左子树**上所有结点的值均**小于根结点**；
* 若右子树非空，则**右子树**上所有结点的值均**大于根结点**；
* 左右子树也分别是一颗二叉排序树

根据以上定义，左子树结点值<根结点值<右子树结点值，所以可以通过**中序遍历**得到一个**递增的有序序列**。

**二叉排序树的查找**

从根结点开始，沿着某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点进行比较，若相等则查找成功，若不等，如果小于根节点关键字则在左子树上查找，否则在右子树上查找。这是一个递归的过程。

```c
BSTNode *BST_Search(BiTree T, ElemType key) {
    while(T != NULL && key != T->data) {
        if(key < T->data)	T = T->lchild;
        else	T = T->rchild;
    }
    return T;
}
```

**二叉排序树的插入**

二叉排序树作为一种**动态树表**，特点是树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入。

插入结点过程如下：若原二叉排序树为空，则直接插入；否则，若关键字k小于根结点值，插入到左子树，否则插入到右子树。插入的结点一定是一个**新添加的叶子结点**，且是查找失败时查找路径上访问的最后一个结点的左孩子或右孩子。

算法描述如下：

```c
int BST_Insert(BiTree &T, KeyType k) {
	if (T == NULL) {
		T = (BiTree)malloc(sizeof(BSTNode));
		T->key = k;
		T->lchild = T->rchild = NULL;
		return 1;
	}
	else if (k == T->key)
		return 0;
	else if (k < T->key)
		return BST_Insert(T->lchild, k);
	else
		return BST_Insert(T->rchild, k);
}
```

**二叉排序树的构造**

从一颗**空树**出发，依次输入元素，将它们**插入**二叉排序树的合适位置。

算法描述如下：

```c
void Creat_BST(BiTree &T, KeyType str[], int n) {
	T = NULL;	//初始化T为空树
	int i = 0;
	while (i < n) {
		BST_Insert(T, str[i]);	//依次将每个关键字插入二叉排序树中
		i++;
	}
}
```

**二叉排序树的删除**

删除操作按照以下3种情况来处理：

* 若被删除的结点z是**叶子结点**，则直接删除，不会破坏二叉排序树的性质；
* 若结点z**只有一棵左子树或右子树**，则让z的子树成为z父结点的子树，替代z的位置；
* 若结点z**有左右两棵子树**，则令z的**直接后继**替代z，然后从二叉排序树中**删去这个直接后继**，这样就转换为了第一或第二种情况。

**查找效率分析**

查找效率主要取决于树的高度。若二叉排序树的左右子树高度之差的绝对值不超过1，则这样的二叉树成为平衡二叉树，其平均查找长度为$O(\log_2n)$。若二叉排序树是一个只有左（右）孩子的单支树，则平均查找长度为$O(n)$。

### 平衡二叉树

**定义**

为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树的结点时，要保证其任意结点的左右子树**高度差的绝对值不超过1**。

平衡因子：结点左子树与右子树的高度差；平衡二叉树的平衡因子只可能是-1，0，1。

**插入**

每当插入或删除一个结点时，首先检查其插入路径上的结点是否因此导致了不平衡。若导致了不平衡，先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉排序树的特定的前提下，调整各个结点的位置关系，使之重新达到平衡。

将调整规律归纳为以下4种情况：

* LL平衡旋转（右单旋转）：由于在结点A的左孩子的左子树上插入了新的结点，A的平衡因子由1增至2.



* RR平衡旋转（左单旋转）：由于在极点A的右孩子的右子树插入了新的结点，A的平衡因子由-1减至-2



* LR平衡旋转（先左后右双旋转）：



* RL平衡旋转（先右后左双旋转）：



**查找**

在平衡二叉树上进行查找的过程与二叉排序树相同。在查找过程中，与给定值进行比较的关键词个数不超过树的深度。含有n个结点的平衡二叉树的最大深度为$O(\log_2n)$，因此平衡二叉树的平均查找长度为$O(\log_2n)$。

### 哈夫曼树和哈夫曼编码

**定义**

树中的结点被赋予了**权值**；从树的根到任意结点的路径长度与该结点上权值的乘积称为该结点的**带权路径长度**。

树中所有**叶子结点**的带权路径长度之和称为该树的带权路径长度，记为：
$$
WPL=\sum_{i=1}^{n}w_il_i
$$
在含有n个带权叶结点的二叉树中，其中**带权路径长度WPL**最小的**二叉树**称为哈夫曼树，也成为最优二叉树。

**哈夫曼树的构造**

* 将这n个结点分别作为n棵仅含有一个结点的二叉树，构成森林F
* 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根结点的权值之和
* 从F中删除刚才选出的两棵树，同时将新得到的树加入F中
* 重复上两个步骤，直到F中剩余一棵树为止

从以上构造过程可以看出：

* 每个初始结点都成为了叶结点，且权值越小的结点到根结点的路径长度越长
* 构造过程共新建了n-1个结点，因此哈夫曼树的结点总数为2n-1
* 每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树不存在度为1的结点

**哈夫曼编码**

被广泛应用且非常有效的数据压缩编码。是一种可变长度编码，即允许对不同字符用不等长的二进制位表示，对频率高的字符赋予短编码，对频率低的字符赋予长编码，这样能够压缩数据。

* **前缀编码**：没有一个编码是另一个编码的前缀。例如0，101，100就是一组前缀编码。

哈夫曼编码的过程：

* 首先将每个出现的字符当作一个独立的结点，权值为其出现的频度，构造出对应的哈夫曼树
* 所有字符结点都出现在叶子结点中
* 将字符的编码解释为从根至该字符路径上**边标记**的序列，边标记为0表示转向左孩子，边标记为1表示转向右孩子。

由此得到的哈夫曼树拥有最优的WPL。



