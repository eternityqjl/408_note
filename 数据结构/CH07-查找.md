## 基本概念

* 查找：在数据集合中寻找满足某种**条件**的数据元素的过程。查找的结果分为**查找成功和失败**。
* 查找表（查找结构）：用于查找的数据集合。由同一类型的数据元素组成。可以是一个数据或链表等数据结构。对查找表进行的操作有：
  * 查找某特定元素是否在查找表中；
  * 检索满足条件的某特定的数据元素的各种属性；
  * 在查找表中插入一个数据元素；
  * 从查找表中删除一个数据元素。
* **静态查找表**：只涉及以上1和2两个操作。**动态查找表**：能够动态地插入和删除数据元素。
  * 静态查找表的方法：顺序、折半、散列查找
  * 动态查找表的方法：二叉排序树的查找、散列查找
* **关键字**：数据元素中唯一标识该元素的某个数据项
* **平均查找长度**：一次查找的长度指的是需要比较的关键字次数，平均查找长度是所有查找过程中进行关键字的比较次数的平均值。

## 顺序查找和折半查找

### 顺序查找

又称线性查找。对顺序表和链表都适用。

顺序表可通过数组下标递增来顺序扫描每个元素；链表可以通过指针next来依次扫描每个元素。

**一般无序线性表的顺序查找**

* 查找成功的平均查找长度为：$\frac{n+1}{2}$

* 查找失败的平均查找长度为$n+1$

当n比较大时，这种方法的查找效率较低；优点是对数据元素的存储没有要求。

**有序表的顺序查找**

查找前就已经知道表是关键字有序的。查找失败时不用再比较到表的另一端就能返回查找失败的信息。

### 折半查找

又称二分查找，适用于**有序的顺序表**。该查找方法仅适合于顺序存储结构，且要求元素按**关键字有序**排列。

折半查找的过程可用二叉树来描述，详情见书上所示，称为**判定树**。判定树是一颗**平衡二叉树**。

* 查找成功的平均查找长度为$\log_2(n+1)-1$

所以该查找的时间复杂度为$O(\log_2n)$，效率比顺序查找高。

### 分块查找

又称**索引顺序查找**，吸收了顺序和折半查找的优点。既有**动态结构**，又适合于**快速查找**。

基本思想：将查找表分为**若干子块**，**字块之间是有序的**，**块内**的元素可以**无序**，即第一个块中的最大关键字小于第二个块中的所有关键字，以此类推。再建立一个索引表，索引表中的每个元素含有**各块的最大关键字**和**第一个元素的地址**。

步骤：第一步在索引表中确定待查记录所在的块，可以使用顺序或折半查找；第二步是在块内查找。

## B树和B+树

### B树

**概念**

又称**多路平衡查找树**，B树中**所有结点的孩子个数的最大值**称为**B数的阶**，通常用**m**表示。

具有以下特性：

* 树中每个结点至多有**m棵子树**，即至多含有**m-1个关键字**

* 若根结点不是终端结点，则至少有两颗子树。
* 所有非叶子结点的结构：（见书上所示）
* 所有叶子结点都出现在同一层次上，并且不带信息。（可视为类似于折半查找判定树的查找失败结点，实际上这些结点不存在）

B树是所有结点的**平衡因子均等于0**的**多路平衡查找树**。

**B树的高度（磁盘存取次数）**

首先明确B树的高度不包含最后的不带任何信息的叶结点所处的那一层。

假设$n\ge 1$，则对于任意一棵包含n个关键字，高度为h、阶数为m的B树：

* 根据树中关键字个数计算高度满足的范围
* 若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树高度达到最大。

**B树的查找**

与二叉树的查找很相似，只是每个结点都是多个关键字的有序表，要在每个结点上根据该结点的子树做多路分支决定。

包含两个基本操作：

* 在B树中找结点
* 在结点内找关键字

B树常**存储在磁盘中**，因此前一个查找操作是在**磁盘**上进行的，后一个查找操作是在**内存**中进行的，即在找到目标结点后，将其读入内存，然后在结点内采用**顺序或折半**查找方法查找。

**B树的插入**

将关键字插入B树的过程如下：

* **定位**：利用前述的B树查找算法，找出插入该关键字的最低层中的某个非叶结点。
* **插入**：每个非失败结点的关键字个数都在区间$[\lceil m/2\rceil-1,m-1]$内，插入后的结点关键字个数小于m，则可以直接插入；插入后的结点关键字大于m-1时，必须对结点进行**分裂**。

分裂的方法：取一个新结点，在插入key后原结点，从中间位置（$\lceil m/2\rceil$）将其中的关键字分为两部分，左半部分包含的关键字放入原结点中，右半部分包含的关键字放入新节点中，中间位置（$\lceil m/2\rceil$）的结点插入原结点的父结点中；如果父结点关键字个数也超过了上限，则继续进行这种分裂操作，知道这个过程传到根结点为止，进而使得B树的高度增1。

**B树的删除**

与插入的操作类似，即要使得删除后结点中关键字的个数$\ge \lceil m/2\rceil-1$，将会涉及**结点的合并**问题。

* 当被删除关键字k不在终端结点：可以用k的前驱和后继替代k，然后在相应结点中删除该前驱或后继。该前驱或后继必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。
* 当被删除结点在终端结点中时，有以下三种情况：
  * 直接删除关键字。即被删除关键字所在结点的关键字个数$\ge \lceil m/2\rceil$，表明删除后仍满足B树定义。
  * 兄弟够接。被删除前所在结点关键字个数$= \lceil m/2\rceil-1$，且与此结点相邻的兄弟结点的关键字个数$\ge \lceil m/2\rceil$，需要通过父子换位法进行调整，达到新的平衡。
  * 兄弟不够接。被删除前所在结点关键字个数$= \lceil m/2\rceil-1$，且与此结点相邻的兄弟结点的关键字个数$= \lceil m/2\rceil -1$，则要将关键字删除后与左右兄弟结点及双亲结点中的关键字进行合并。合并过程中双亲结点中关键字会-1，若其双亲结点是根结点且关键字个数减少为0，则直接将根结点删除，合并后的新结点称为根结点。

详细例子见书上。

### B+树

是B树的一种变形。一个**m阶B+树**要满足以下条件：

* 每个分支结点**最多有m棵子树**（孩子结点）
* 非叶根节点至少有两棵子树，其他每个分支结点至少有$ \lceil m/2\rceil$棵子树。
* 结点的**子树个数与关键字个数相等**
* 所有**叶结点**包含**全部关键字**及**指向相应记录的指针**，叶结点中将关键字按大小顺序排序，并且相邻叶结点按大小顺序相互链接起来。
* 所有分支结点只包含它的子结点中关键字的最大值以及指向其子结点的指针。

![B+树](https://raw.githubusercontent.com/eternityqjl/blogGallery/master/B%2B%E6%A0%91.jpg)

通常B+树有两个头指针：一个**指向根结点**，另一个**指向关键字最小的叶结点**。因此对B+树进行两种查找运算：

* 从最小关键字开始的**顺序查找**
* 从根结点开始的**多路查找**

## 红黑树

又称为对称二叉B树。

是一种含有红黑结点并能自平衡的二叉查找树。满足以下性质：

* 每个结点要么是黑色，要么是红色
* 根结点是黑色
* 每个叶子结点是黑色
* 每个红色结点的两个子结点一定都是黑色
* 任意一个结点到每个叶子结点的路径都包含相同数量的黑结点。





## 散列表（哈希表）

### 基本概念

* 散列函数：一个把查找表中的**关键字**映射成该关键字对应的**地址**的函数，记为：Hash(key)=Addr（这里的地址可以是数组下标、索引或内存地址等）

散列函数可能会把多个不同关键字映射到同一地址，这种情况称为冲突，这些**发生碰撞的不同关键词**称为**同义词**。一方面我们要避免冲突，另一方面要设计好处理冲突的方法。

* 散列表：根据关键字而直接进行访问的数据结构，即建立了**关键字**和**存储地址**之间的一种直接映射。理想状况下对散列表进行查找的时间复杂度为O(1)，与表中元素个数无关。

### 散列函数的构造方法

构造散列函数时的注意事项：

* 散列函数的定义域要包含**全部的关键字**，而值域范围则依赖于散列表大小或地址范围。
* 散列函数计算出的地址应该能**等概率、均匀地**分布在整个地址空间中
* 散列函数应**尽量简单**，能在**较短时间内计算出**任一关键字对应的散列地址。

**直接定址法**

直接取关键字的某个线性函数值为散列地址，散列函数为：
$$
H(key)=key或H(key)=a\times key +b
$$
这种方法较为简单且不会产生冲突，适合关键字分布基本连续的情况。

**除留余数法**

一种最简单、最常用的方法。假定散列表表厂为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址：
$$
\text{H(key)=key\%p}
$$
该方法的关键是选好p。

**数字分析法**



**平方取中法**

取关键字的平方值的中间几位作为散列地址。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

### 处理冲突的方法

发生冲突时的处理方法，即为产生冲突的关键字寻找**下一个空的Hash地址**。

**开放定址法**

开放定址法指的是**可存放新表项的空闲地址**既向它的**同义**表项开放，又向它的**非同义**词表项开放。数学递推公式为：
$$
H_i=(H(key)+d_i)\%m
$$
$H(key)$为散列函数；i=0,1,2,...,k；$m$表示散列表表长；$d_i$为增量序列。

取定某一增量序列后，对应处理方法就确定了，通常有以下四种取法：

* **线性探测法**：$d_i=0,1,2,...,m-1$。冲突发生时，顺序查看表中**下一个单元**，直到找出一个空闲地址或查遍全表。这种方法可能会造成大量元素在**相邻散列地址上的聚集**，大大降低了查找效率。
* **平方探测法**：$d_i=0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2$。其中$k\leq m/2$，散列表m的长度m必须是一个可以表示成4k+3的素数。平方探测法可以**避免堆积**，但是不能探测到散列表上的所有单元。
* **再散列法**：$d_i=Hash_2(key)$。需要使用**两个散列函数**。利用第二个散列函数计算该关键字的地址增量。
* **伪随机序列法**：$d_i=伪随机序列$。

**拉链法**

把所有的同义词存储在**一个线性链表**中，这个线性链表由其散列地址唯一标识。这种方法适用于**经常进行插入和删除**的情况。

### 散列查找及性能分析

查找过程的具体举例见书上。

**性能分析**

* 虽然散列表建立了关键字与记录的存储位置之间的直接映射，但由于冲突的存在，导致查找过程仍是一个**给定值和关键字的比较**过程，仍需以**平均查找长度**衡量散列表的查找效率。

* 散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。

* 装填因子：定义为一个表的装满程度，即：
  $$
  \alpha=\frac{表中记录数n}{散列表长度m}
  $$
  散列表的平均查找长度依赖于装填因子a，而不直接依赖于n或m。**a越大，装填得越慢，发生冲突的可能性越大**。

