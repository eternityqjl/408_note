## 基本概念

### 排序的定义

排序是重新排列列表中的元素，使表中的元素按关键字有序的过程。

* 算法的稳定性：若待排序表中有两个元素$R_i$和$R_j$，二者对应的关键字相同，且i在j的前面，若使用某一排序算法后i仍然在j的前面，则称该算法是稳定的，否则不稳定。

根据排序过程中数据元素是否完全在内存中，可以将排序算法分为：

* 内部排序：排序期间元素全部存放在内存中。
* 外部排序：排序期间元素无法全部同时存放在内存中，必须在排序过程中不断按照要求在内、外存之间移动的排序。

内部排序算法在执行过程中一般都要进行两种操作：比较和移动。通过比较关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。



## 插入排序

每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。

### 直接插入排序

无序序列的第一个元素为有序，首先从第二个元素开始到无序序列的末尾，依次找出每个元素在前面已经排好序的序列中的位置；然后将该位置后的所有元素依次向后移动一位；最后将元素插入该位置。以此类推。

代码实现如下：

```c
void InsertSort(ElemType A[], int n) {
	int i, j;
	for (i = 2; i <= n; i++)
	{//从第二位元素开始，将无序序列的每个元素都插入有序序列中
		if (A[i] < A[i-1]) {	//如果当前元素小于前一位元素，即小于有序序列的最后一位，则执行插入操作；否则直接放在有序序列的最后一位。
			A[0] = A[i];	//A[0]不存放元素，作为哨兵
			for (j = i-1; A[j] > A[0]; j--)	//将当前位置后的所有元素依次向后移动一位
				A[j+1] = A[j];
			A[j+1] = A[0];
		}
	}
}
```

**性能分析**

* 空闲复杂度：$O(1)$

* 时间复杂度：$O(n^2)$

* 稳定性：直接插入算法是一个**稳定**的排序算法

* 适用性：适用于顺序存储和链式存储的线性表

  > 大部分排序算法都只适用于顺序存储的线性表

### 折半插入排序

该方法将比较和移动分离。先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。

代码实现如下：

```c
void InsertSort(ElemType A[], int n) {
	int i, j, low, high, mid;
	for (i = 2; i<= n; i++) {
		A[0] = A[i];
		low = 1; high = i - 1;	//折半查找的范围
		while (low <= high) {	//折半查找
			mid = (low + high) / 2;
			if (A[mid] > A[0])	high = mid - 1;
			else low = mid + 1;
		}
		for (j = i - 1; j >= high + 1; --j)
			A[j + 1] = A[j];	//统一后移操作，空出插入位置
		A[high + 1] = A[0];
	}
}
```

**性能分析**

折半插入排序仅减少了比较元素次数，约为$O(n\log_2 n)$，该比较次数只与n有关；元素的移动次数并未改变，依赖于排序表的初始状态。因此，折半插入排序的时间复杂度仍$为O(n^2)$，但对于数据量不大的排序表，有着较好的性能。折半排序是一种稳定的排序方法。

### 希尔排序

基本思想：将待排序表分割为**若干个等长的子表**，即把相隔某个增量的所有元素组成一个子表，对各个子表分别进行插入排序，当整个表中的元素已经基本有序时，在对全体记录进行依次直接插入排序。局部有序性。

增量即为划分的子序列的个数。

增量序列的常用方法有：$d_1=n/2,$，$d_{i+1}=d_i/2$.

代码实现如下：

```c
void ShellSort(ElemType A[], int n) {
    for (dk = n/2; dk >= 1; dk = dk/2)	//步长变化
        for (i = dk + 1; i <= n; ++i)
            
        
}
```

**性能分析**

空间复杂度：$O(1)$

时间复杂度：依赖于增量序列的函数，当n在某个特定范围时，希尔排序的时间复杂度为$O(n^{1.3})$，最坏情况下的时间复杂度为$O(n^2)$

稳定性：希尔排序是一个**不稳定**的排序方法

适用性：适用于线性表为顺序存储的情况。

## 交换排序

根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

### 冒泡排序

基本思想：从后往前后从前往后**两两比较相邻元素**，若为逆序（$A[i-1]>A[i]$），则交换它们，直到序列比较完。称为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟最小的元素将不再参与，以此类推，最多做n-1趟冒泡就能把所有元素排好序。



**性能分析**

空间复杂度：$O(1)$

时间复杂度：最坏时为$O(n^2)$，平均也为$O(n^2)$

稳定性：**稳定**，即元素相等时不会发生交换。

### 快速排序

是基于分治的思想，在待排序表中任取一个元素pivot作为轴枢元素，通过一趟排序将排序表划分为两个部分$L[1....k-1]$和$L[k+1....n]$，使得$L[1....k-1]$中的所有元素小于pivot，$L[k+1....n]$中的所有元素大于pivot，此时pivot放在了其最终位置L(k)上，然后分别对两个子表重复上述过程，直至每部分内只有一个元素或为空，所有元素就都放在了最终位置。

快速排序算法的关键在于**划分操作**，而考研数学考察的快速排序的划分操作为每次总以当前表中**第一个元素**作为枢轴对表进行划分。

```c
void QuickSort(ElemType A[], int low, int high) {
	if (low < high) {
		int pivotpos = Partition(A, low, high);	//划分
		QuickSort(A, low, pivotpos - 1);	//依次对两个子表进行递归排序
		QuickSort(A, pivotpos + 1, high);
	}
}
int Partition(ElemType A[], int low, int high) {
	ElemType pivot = A[low];	//将当前表的第一个元素设置为轴枢，对表进行划分
    while (low < high) {
        while (low < high && A[high] >= pivot)	--high;
        A[low] = A[high];	//比轴枢小的元素移动到左端
        while (low < high && A[low] <= pivot)	++low;
        A[high] = A[low];	//比轴枢大的元素移动到右端
    }
    A[low] = pivot;	//轴枢元素移动到最终位置
    return low;	//f
}
```



**性能分析**

空间复杂度：递归过程需要借助一个递归工作栈，最好的情况为$O(\log_2 n)$；最坏情况下栈的深度为$O(n)$，平均情况下为$O(\log_2 n)$

时间复杂度：平均情况下为$O(n\log_2 n)$

快速排序是**所有内部排序算法**中**平均性能最优**的排序算法。

## 选择排序

### 简单选择排序

基本思想：每一趟（例如第i趟）在后面n-i+1个待排元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下一个，就不用再选了。

**性能分析**

* 空间复杂度：$O(1)$
* 时间复杂度：元素移动操作次数较少，但比较次数较多，时间复杂度为$O(n^2)$
* 稳定性：不稳定，可能导致相同关键字元素顺序变化

### 堆排序

**堆的定义**

n个关键字序列L[1...n]称为堆，满足：

* L(i)>L(2i)且L(i)>=L(2i+1)或
* L(i)<L(2i)且L(i)<=L(2i+1)

可以将该一维数组视为一颗完全二叉树，满足上面第一个条件的称为**大根堆（大顶堆）**，大根堆的最大元素存放在根结点，且任一非根结点的值小于等于其双亲结点值。满足第二个条件的称为**小根堆**，定义刚好相反，根结点为最小元素。

**堆排序**

算法思路：首先将存放在L[1...n]中的n个元素建成初始堆（大顶堆），堆顶元素就是最大值。输出堆顶元素后，将堆底元素送入堆顶，此时根结点已经不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。

堆排序的两个主要问题：

* 如何将无序序列构造为堆
* 输出栈顶元素后，如何将剩余元素调整为新的堆

以上两个具体算法的分析见书上的例子。

**性能分析**

* 空间复杂度：$O(1)$
* 时间复杂度：建堆时间为$O(n)$，进行一次堆调整的时间为$O(\log_2 n)$；堆排序的时间复杂度在最好、最坏和平均情况下都为$O(n\log_2 n)$。
* 稳定性：不稳定



## 归并排序和基数排序

### 归并排序

归并是将两个或两个以上的有序表组合成一个新的有序表。假设待排序表含有n个记录，则可将其视为有n个有序的子表，每个子表的长度为1，然后两两归并，得到n/2个长度为2或1的有序表；继续两两归并，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2路归并排序。

Merge()的功能是将前后相邻的两个有序表归并为一个有序表。两段有序表A[low...mid]和A[mid+1...high]存放在同意顺序表的相邻位置，先将它们复制到辅助数组B中。每次从B中的两个段取出一个记录进行关键字比较，将较小者放入A中，当数组B中有一段的下标超出其对应表长时，将另一端的剩余部分直接复制到A中。算法实现如下：

```

```

递归形式的2路归并排序是基于分治的，过程如下：

* 分解：将含有n个元素的待排序表分成各含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。
* 合并：合并两个已经排序的子表得到排序结果。

**性能分析**

* 空间复杂度：辅助单元为n个单元，所以$O(n)$
* 时间复杂度：每趟归并的时间复杂度为$O(n)$，共需要进行$O(\log_2 n$)趟归并，所以算法的时间复杂度为$O(n\log_2 n)$
* 稳定性：稳定

### 基数排序







## 各种排序算法的比较

### 内部排序算法的比较

基于三个因素进行对比：时空复杂度、算法的稳定性、算法的过程特征



### 内部排序算法的应用

**选取排序方法时需要考虑的因素**





**排序算法小结**







## 外部排序

### 基本概念

前面介绍的排序方法都是在内存中进行的（称为内部排序）。在许多应用中，需要对大文件进行排序，文件中的信息较为庞大，无法将整个文件复制进内存中进行排序。因此需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存中进行排序，在排序过程中需要多次进行内存和外存之间的交换。

### 外部排序的方法





### 多路平衡归并与败者树







### 置换-选择排序

