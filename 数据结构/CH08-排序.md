## 基本概念

### 排序的定义

排序是重新排列列表中的元素，使表中的元素**按关键字有序**的过程。

* **算法的稳定性**：若待排序表中有两个元素$R_i$和$R_j$，二者对应的关键字相同，且$i$在$j$的前面，若使用某一排序算法后$i$仍然在$j$的前面，则称该算法是稳定的，否则不稳定。

根据排序过程中数据元素是否完全在内存中，可以将排序算法分为：

* **内部排序**：排序期间元素全部存放在内存中。
* **外部排序**：排序期间元素无法全部同时存放在内存中，必须在排序过程中不断按照要求在内、外存之间移动的排序。

内部排序算法在执行过程中一般都要进行两种操作：**比较和移动**。通过比较关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。

## 插入排序

每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。

### 直接插入排序

无序序列的第一个元素为有序，首先从第二个元素开始到无序序列的末尾，依次找出每个元素在前面已经排好序的序列中的位置；然后将该位置后的所有元素依次向后移动一位；最后将元素插入该位置。以此类推。

代码实现如下：

```c
void InsertSort(ElemType A[], int n) {
	int i, j;
	for (i = 2; i <= n; i++)
	{//从第二位元素开始，将无序序列的每个元素都插入有序序列中
		if (A[i] < A[i-1]) {	//如果当前元素小于前一位元素，即小于有序序列的最后一位，则执行插入操作；否则直接放在有序序列的最后一位。
			A[0] = A[i];	//A[0]不存放元素，作为哨兵
			for (j = i-1; A[j] > A[0]; j--)	//将当前位置后的所有元素依次向后移动一位
				A[j+1] = A[j];
			A[j+1] = A[0];
		}
	}
}
```

**性能分析**

* 空闲复杂度：$O(1)$

* 时间复杂度：$O(n^2)$

* 稳定性：直接插入算法是一个**稳定**的排序算法

* 适用性：适用于顺序存储和链式存储的线性表

  > 大部分排序算法都只适用于顺序存储的线性表

### 折半插入排序

该方法将**比较和移动分离**。先折半查找出元素的**待插入位置**，然后统一地移动待插入位置之后的所有元素。

代码实现如下：

```c
void InsertSort(ElemType A[], int n) {
	int i, j, low, high, mid;
	for (i = 2; i<= n; i++) {
		A[0] = A[i];
		low = 1; high = i - 1;	//折半查找的范围
		while (low <= high) {	//折半查找
			mid = (low + high) / 2;
			if (A[mid] > A[0])	high = mid - 1;
			else low = mid + 1;
		}
		for (j = i - 1; j >= high + 1; --j)
			A[j + 1] = A[j];	//统一后移操作，空出插入位置
		A[high + 1] = A[0];
	}
}
```

**性能分析**

折半插入排序仅**减少了比较元素次数**，约为$O(n\log_2 n)$，该比较次数只与n有关；元素的**移动次数并未改变**，依赖于排序表的初始状态。因此，折半插入排序的时间复杂度仍$为O(n^2)$，但对于数据量不大的排序表，有着较好的性能。折半排序是一种**稳定**的排序方法。

### 希尔排序

基本思想：将待排序表分割为**若干个等长的子表**，即把**相隔某个增量**的所有元素组成一个子表，对**各个子表**分别进行**插入排序**，当整个表中的元素已经基本有序时，再对全体记录进行依次**直接插入**排序。**局部有序性**。

增量即为划分的子序列的个数。

增量序列的常用方法有：$d_1=n/2,$，$d_{i+1}=d_i/2$，直到最后一个增量等于1。

代码实现如下：

```c
void ShellSort(ElemType A[], int n) {
    for (dk = n/2; dk >= 1; dk = dk/2)	//步长变化
        for (i = dk + 1; i <= n; ++i)	//遍历每个子表
            if (A[i] < A[i - dk]) {	//对子表进行插入排序
                A[0] = A[i];	//暂存在A[0]
                for (j = i - dk; j > 0 && A[0] < A[j]; j -= dk)
                    A[j - dk] = A[j];
                A[j + dk] = A[0];
            }
}
```

**性能分析**

空间复杂度：$O(1)$

时间复杂度：依赖于增量序列的函数，当n在某个特定范围时，希尔排序的时间复杂度为$O(n^{1.3})$，最坏情况下的时间复杂度为$O(n^2)$

稳定性：希尔排序是一个**不稳定**的排序方法

适用性：适用于线性表为顺序存储的情况。

## 交换排序

根据序列中两个元素**关键字的比较结果**来**对换**这两个记录在序列中的位置。

### 冒泡排序

基本思想：从后往前后从前往后**两两比较相邻元素**，若为逆序（$A[i-1]>A[i]$），则交换它们，直到序列比较完。称为第一趟冒泡，结果是将**最小的元素**交换到待排序列的**第一个位置**。下一趟冒泡时，前一趟最小的元素将不再参与，以此类推，**最多做n-1趟**冒泡就能把所有元素排好序。

代码实现如下：

```c
void BubbleSort(ElemType A[], int n) {
    for (int i = 0; i < n; i++) {
        flag = false;
        for (j = n - 1; j > i; j--) {
            if (A[j] < A[j - 1]) {
                swap(A[j - 1], A[j]);
                flag = true;
            }
        }
        if (flag == false)
            return;	//本趟遍历没有发生交换，说明表已经有序
    }
}
```

**性能分析**

空间复杂度：$O(1)$

时间复杂度：最坏时为$O(n^2)$，平均也为$O(n^2)$

稳定性：**稳定**，即元素相等时不会发生交换。

### 快速排序

是基于**分治**的思想，在待排序表中任取一个元素pivot作为**轴枢**元素，通过一趟排序将排序表划分为两个部分$L[1....k-1]$和$L[k+1....n]$，使得$L[1....k-1]$中的所有元素**小于**pivot，$L[k+1....n]$中的所有元素**大于**pivot，此时pivot放在了其**最终位置L(k)**上，然后分别对**两个子表重复上述过程**，直至每部分内**只有一个元素或为空**，所有元素就都放在了最终位置。

快速排序算法的关键在于**划分操作**，而考研数学考察的快速排序的划分操作为每次总以当前表中**第一个元素**作为枢轴对表进行划分。

代码实现如下所示：

（划分的详细过程举例见书上）

```c
void QuickSort(ElemType A[], int low, int high) {
	if (low < high) {
		int pivotpos = Partition(A, low, high);	//划分
		QuickSort(A, low, pivotpos - 1);	//依次对两个子表进行递归排序
		QuickSort(A, pivotpos + 1, high);
	}
}
int Partition(ElemType A[], int low, int high) {
	ElemType pivot = A[low];	//将当前表的第一个元素设置为轴枢，对表进行划分
    while (low < high) {
        while (low < high && A[high] >= pivot)	--high;
        A[low] = A[high];	//比轴枢小的元素移动到左端
        while (low < high && A[low] <= pivot)	++low;
        A[high] = A[low];	//比轴枢大的元素移动到右端
    }
    A[low] = pivot;	//轴枢元素移动到最终位置
    return low;	//f
}
```

**性能分析**

空间复杂度：递归过程需要借助一个**递归工作栈**，最好的情况为$O(\log_2 n)$；最坏情况下栈的深度为$O(n)$，平均情况下为$O(\log_2 n)$

时间复杂度：平均情况下为$O(n\log_2 n)$

快速排序是**所有内部排序算法**中**平均性能最优**的排序算法。

## 选择排序

### 简单选择排序

基本思想：每一趟（例如第i趟）在后面n-i+1个待排元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下一个，就不用再选了。

```c
void SelectSort (ElemType A[], int n) {
    for (int i = 0; i < n; i++) {
        min = i;
        for (j = i + 1; j < n; j++) {
            if (A[j] < A[i])
                min = j;
        }
        if (min != i)
            swap(A[i], A[min]);
    }
}
```

**性能分析**

* 空间复杂度：$O(1)$
* 时间复杂度：元素移动操作次数较少，但比较次数较多，时间复杂度为$O(n^2)$
* 稳定性：**不稳定**，可能导致相同关键字元素顺序变化

### 堆排序

**堆的定义**

n个关键字序列L[1...n]称为堆，满足：

* L(i)>L(2i)且L(i)>=L(2i+1)或
* L(i)<L(2i)且L(i)<=L(2i+1)

可以将该一维数组视为**一棵完全二叉树**，满足上面第一个条件的称为**大根堆（大顶堆）**，大根堆的**最大元素**存放在**根结点**，且任一非根结点的值小于等于其双亲结点值。满足第二个条件的称为**小根堆**，定义刚好相反，根结点为最小元素。

**堆排序**

算法思路：首先将存放在L[1...n]中的n个元素建成初始堆（大顶堆），堆顶元素就是最大值。输出堆顶元素后，将堆底元素送入堆顶，此时根结点已经不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。

堆排序的两个主要问题：

* 如何**将无序序列构造为堆（构造初始堆）**
* 输出栈顶元素后，如何**将剩余元素调整为新的堆**

（1）构造初始堆：

n个结点的完全二叉树，最后一个结点是第$\lfloor n/2 \rfloor $个结点的孩子，对第$\lfloor n/2 \rfloor $为根的子树交换，使该子树成为堆，之后依次向前对各结点（$\lfloor n/2 \rfloor -1$到$1$）为根的子树进行交换，使之成为堆，交换后可能破坏下一级的堆，于是继续采用上述方法对二叉树进行调整，使之成为堆。

（2）输出堆顶并进行调整

以上两个具体算法的分析见书上的例子。

建立大根堆的代码：

```c
void BuildMaxHeap(ElemType A[], int len) {
    for (int i = len/2; i > 0; i--)	//从i=[n/2]~1反复调整堆
        HeadAdjust(A, i, len);
}
void HeadAdjust (ElemType A[], int k, int len) {
    //该函数将元素k为根的子树进行调整
    A[0] = A[k];	//A[0]暂存子树的根结点
    for (i = 2*k; i <= len; i *= 2) {
        if (i < len && A[i] < A[i + 1])
            i++;
        if (A[0] >= A[i])	break;
        else {
            A[k] = A[i];
            k = i;	//继续向下筛选
        }
    }
    A[k] = A[0];
}
```

堆排序算法的代码：

```c
void HeapSort (ElemType A[]. int len) {
    BuildMaxHeap (A, len);
    for (i = len; i > 1; i--) {
        Swap(A[i], A[1]);	//输出堆顶元素（与堆底元素进行交换）
        HeadAdjust(A, 1, i-1);
    }
}
```

**性能分析**

* 空间复杂度：$O(1)$
* 时间复杂度：建堆时间为$O(n)$，进行一次堆调整的时间为$O(\log_2 n)$；堆排序的时间复杂度在最好、最坏和平均情况下都为$O(n\log_2 n)$。
* 稳定性：**不稳定**

## 归并排序和基数排序

### 归并排序

归并是将**两个或两个以上的有序表**组合成一个**新的有序表**。假设待排序表含有n个记录，则可将其视为有n个有序的子表，每个子表的长度为1，然后两两归并，得到n/2个长度为2或1的有序表；继续两两归并，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为**2路归并排序**。

Merge()的功能是将前后相邻的两个有序表归并为一个有序表。两段有序表A[low...mid]和A[mid+1...high]存放在同一顺序表的相邻位置，先将它们复制到辅助数组B中。每次从B中的两个段取出一个记录进行关键字比较，将较小者放入A中，当数组B中有一段的下标超出其对应表长时，将另一端的剩余部分直接复制到A中。算法实现如下：

```

```

递归形式的2路归并排序是基于分治的，过程如下：

* **分解**：将含有n个元素的待排序表分成各含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。
* **合并**：合并两个已经排序的子表得到排序结果。

`Merge()`是用来把前后两个相邻的两个有序表归并为一个有序表。需要使用一个辅助数组B。设两个有序表为`A[low...mid]、A[mid+1...high]`存放在同一顺序表中的相邻位置。

```c
ElemType *B = (ElemType *) malloc ((n+1) * sizeof(ElemType));	//创建辅助数组B
void Merge(ElemType A[], int low, int mid, int high) {
    for (int k = low; k <= high; k++)
        B[k] = A[k];
    for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) {
        if (B[i] < B[j])
            A[k] = B[i++];
        else
            A[k] = B[j++]
    }
    while (i <= mid)	A[k++] = B[i++];
    while (j <= high)	A[k++] = B[j++];
}
```

递归的二路归并排序算法：

```c
void MergeSort(ElemType A[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid + 1, high);
        Merge(A, low, high);
    }
}
```

**性能分析**

* 空间复杂度：辅助单元为n个单元，所以$O(n)$
* 时间复杂度：每趟归并的时间复杂度为$O(n)$，共需要进行$O(\log_2 n$)趟归并，所以算法的时间复杂度为$O(n\log_2 n)$
* 稳定性：稳定

### 基数排序

基数排序是基于**关键字各位的大小**进行排序。

为实现多关键字排序，通常有两种方法：第一种是最高位优先（MSD）法，按关键字位权重递减一次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。

第二种是最低位优先法，按关键字权重递增依次进行排序，最后形成一个有序序列。



## 各种排序算法的比较

### 内部排序算法的比较

基于三个因素进行对比：时空复杂度、算法的稳定性、算法的过程特征

![排序算法性能比较](https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.jpg)



### 内部排序算法的应用

**选取排序方法时需要考虑的因素**





**排序算法小结**







## 外部排序

### 基本概念

前面介绍的排序方法都是在内存中进行的（称为内部排序）。在许多应用中，需要对**大文件**进行排序，文件中的信息较为庞大，无法将整个文件复制进内存中进行排序。因此需要将待排序的记录存储在**外存**上，排序时再把数据**一部分一部分地调入内存中**进行排序，在排序过程中需要**多次进行内存和外存之间的交换**。

### 外部排序的方法

文件按块存储在磁盘中，操作系统也是按块对磁盘上的信息进行读写。磁盘的I/O时间远超内存运算时间，所以时间代价主要考虑**访问磁盘的次数**。

外部排序通常采用**归并排序法**，主要包括以下两个阶段：

* 根据内存缓存区大小，将外存上的文件分成若干长度为l的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后的有序子文件重新写回外存，称这些有序子文件为**归并段**或顺串。
* 对这些归并段进行**逐趟归并**，使归并段逐渐由小到大，直到得到整个有序文件为止。



### 多路平衡归并与败者树







### 置换-选择排序

