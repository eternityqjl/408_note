## 进程与线程

### 进程的概念和特征

**概念**

多道程序环境下，引入进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的**并发性和共享性**。

为了使得参与并发执行的程序(包含数据)能够独立地运行，必须为之配置一个专门的数据结构，称为**进程控制块(PCB)**。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由**程序段、相关数据段和PCB**三部分构成了**进程映像**（实体）。创建进程实质上是创建**进程映像中的PCB**，撤销进程实际上是撤销进程的PCB。

PCB是**进程存在**的唯一标志。

**特征**

* 动态性：进程是程序的依次执行，它有着创建、活动、暂停、终止等过程，具有一定的**生命周期**。
* 并发性：多个进程实体同时存在于**内存**中。
* 独立性：进程实体是一个能独立运行、独立获得资源、独立接受调度的基本单位
* 异步性：进程之间相互制约，按照各自独立的、不可预知的速度向前推进；异步性会导致执行结果不可再现，因此在操作系统中必须配置相应的同步机制。
* 结构性：进程实体由程序段、数据段、PCB三部分组成。

### 进程的状态与转换

* **运行态**：进程正在处理机上运行。单处理机环境下每个时刻最多只有一个进程处于运行态。
* **就绪态**：进程获得除了处理机外的一切资源，一旦获得处理机资源，就可以立即运行。系统中可能有多个处于就绪态的进程，它们排成一个队列，称为就绪队列。
* **阻塞态**（等待态）：进程正在等待某一时间而暂停，可能是I/O完成或等待某资源成为可用。
* 创建态：进程正在被创建，尚未转到就绪态。创建过程：首先申请一个PCB，并向PCB中写入一些控制和管理进程的信息，然后系统为进程分配所需的资源，最后把进程转入就绪态。
* 结束态：进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。

整个系统的3种基本状态之间的转换：

* 就绪态$\rightarrow$运行态
* 运行态$\rightarrow$就绪态：处于运行态的程序在时间片用完后不得不让出处理机，从而从运行态转为就绪态
* 运行态$\rightarrow$阻塞态：进程请求某一资源的使用和分配或登台某一之间的发生时，就从运行态转换为阻塞态
* 阻塞态$\rightarrow$就绪态：进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应的进程的状态转换为就绪态

### 进程控制

对系统中所有进程实施有效的管理，具有**创建新进程、撤销已有进程、实现进程状态转换**等功能。操作系统中一般把**进程控制用的程序段**称为**原语**。原语执行期间不允许中断，是一个不可分割的单位。

**进程的创建**

允许一个进程创建另一个进程，创建者称为父进程，被创建的进程称为子进程，子进程可以继承父进程拥有的资源。

操作系统创建一个新进程（原语）的过程如下：

* 为新进程分配一个唯一的进程标识号（PID），并申请一个**空白的PCB**。
* 为进程分配资源，即必要的**内存空间**；若资源不足，并不是创建失败，而是处于阻塞态
* **初始化PCB**，主要包括初始化标志信息、处理机状态信息和控制信息、进程的优先级
* 若就绪队列能够接纳新进程，则将新进程**插入就绪队列**

**进程的终止**

引起进程终止的事件有：

* 正常结束，任务已经完成准备退出运行
* 异常结束，进程运行时发生了异常事件，如存储区越界、非法指令等。
* 外界干预：进程应外界的请求而终止运行，如操作系统干预、父进程终止等。

操作系统终止进程的过程；

* 根据终止进程的PID，检索PCB，从中读出进程状态
* 若处于执行状态，则立即终止该进程，将处理机资源释放
* 若该进程有子孙进程，则将所有子孙进程终止
* 将该进程的所有资源归还
* 将该PCB从所在队列（链表）中删除

**进程的阻塞和唤醒**

正在执行的进程，由于期待某些事情发生，如等待某种操作的完成、新数据尚未到达等，由系统自动执行**阻塞原语Block**，使自己由运行态变为阻塞态；阻塞是进程自身的一种行为，只有处于运行态的进程才能转换为阻塞态。阻塞原语的执行过程如下：

* 找到要被阻塞进程的PID对应的PCB
* 保护现场，将其状态转为阻塞态，停止运行。
* 将该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。

当被阻塞进程所期待的事件出现时，调用**唤醒原语Wakeup**将其唤醒：

* 在该事件的等待队列中找到相应进程的PCB
* 将其从等待队列中移除，置为就序列
* 将其插入就绪队列，等待调度

**进程切换**

进程切换在内核的支持下实现。进程切换指的是处理机从一个进程的运行转到另一个进程的运行，过程如下：

* 保存处理机上下文，包括程序计数器和其他寄存器
* 更新PCB信息
* 将进程的PCB移入相应队列，如就绪、在某事件阻塞等队列
* 选择另一个进程执行，更新其PCB
* 更新内存管理的数据结构
* 恢复处理机的上下文

> 注：**进程调度**是决定资源分配给哪个进程的行为，是一种**决策行为**；**进程切换**是指实际分配的行为，是**执行行为**。一般先有调度后有执行。

### 进程的组织

进程是操作系统进行资源分配和调度的基本单位。由以下三部分组成，其中最核心的时进程控制块（PCB）。

**进程控制块**

进程创建时，操作系统为其分配一个新的PCB，PCB常驻内存，任何时刻都可以存取，在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。

进程运行过程中PCB的使用：

* 系统要调度进程运行时，要从进程的PCB中查出其**现行状态和优先级**。

* 调度到某进程后，要根据PCB中的处理机状态信息设置进程的**恢复运行的现场**，根据程序和数据的内存地址，找到**程序和数据**。

* 进程运行过程中，需要**和其他进程实现同步、通信或访问文件**时，也需要访问PCB
* 当进程由于一些原因**暂停运行**时，需要将其断点的处理机环境保存到PCB中。

PCB包含的各个部分：

* 进程描述信息：进程标识符PID和用户标识符UID
* 进程控制和管理信息：当前状态、优先级
* 资源分配清单：用于说明有关内存地址空间和虚拟地址空间的状况
* 处理机相关信息：处理机中各寄存器的值，便于在该进程被重新执行时能从断电继续运行

系统组织各进程的所有PID的方式：

* 链接方式：将同一状态的PCB链接成一个**队列**，不同状态对应不同队列
* 索引方式：将同一状态的PCB组织在一个索引表中，索引表的表项指向相应的PCB

**程序段**

能被进程调度程序调度道CPU执行的代码；程序可以被多个进程共享。

**数据段**

可以是进程对应的程序加工处理的原始数据，或者程序执行时产生的中间或最终结果。

### 进程的通信

指**进程之间的信息交换**。

**共享存储**

通信进程之间存在一块可以直接访问的共享空间，通过对这块共享空间进行读/写操作实现进程之间交换信息。

对共享空间进行读写时，需要使用**同步互斥工具**（P操作、V操作）。

共享存储分为：

* 低级方式：基于数据结构的共享
* 高级方式：基于存储区的共享

操作系统只提供可共享使用的存储空间和同步互斥工具，数据交换用户自行安排读写指令完成。

**消息传递**

该系统中，进程间的数据交换以**格式化的消息**为单位。这种方法用于进程之间不存在可以直接访问的共享空间。

进程通过系统提供的发送消息和接收消息两个原语进行数据交换。

* 直接通信方式：发送进程把消息发送给接收进程，并将其挂在接收进程的缓冲队列上
* 间接通信方式：发送进程把消息发送给某个中间实体，接收进程从实体中获得消息

**管道通信**

管道（pipe文件）是用于链接一个读进程和一个写进程以实现它们之间通信的一个共享文件夹，采用半双工通信。

写进程以字符流的形式将大量数据写入管道；接收进程从管道中读数据。管道机制提供三个方面的协调能力：互斥、同步、确定管道存在。

管道和一般文件有所不同，能克服使用文件进行通信时的两个问题：

* 限制管道的大小。管道是一个固定大小的缓冲区。
* 读进程可能比写进程快，当管道中所有数据已经被读取完后，这时管道中read()调用将被默认阻塞

### 线程概念和多线程模型

**线程基本概念**
引入线程的目的是减小程序在**并发执行**时所付出的开销，提高操作系统的并发性能。

线程的直接理解就是轻量级进程，它是一个**基本的CPU执行单元**，也是程序执行流的**最小单元**，由线程ID、程序计数器、寄存器集合和堆栈组成。

线程是进程中的一个实体，是被系统独立调度和分配的基本单元，线程自己不拥有系统资源，而是与其他属于同一进程的多个线程共享进程的所有资源。

一个线程可以创建和撤销另一个线程，同一进程中的多个线程可以并发执行。线程之间相互制约，运行中存在间断性，拥有运行态、就绪态和阻塞态三种状态。

引入线程后，进程的内涵发生了变化，只作为除了CPU外系统资源的分配单元，线程则作为处理机的分配单元。线程之间的切换只需要花费很少的时空空间。

线程切换时只需要保存和设置少量寄存器，开销很小。另外多个线程共享进程的地址空间，同步和通信很容易实现，无需系统干预。

**线程的实现方式**

* 用户级线程：有关线程管理的所有工作都由应用程序完成，内核和意识不到线程的存在，应用程序通过线程库来实现。
* 内核级线程：线程管理的所有工作由内核完成，线程管理对应用程序透明，只有一个到内核级线程的编程接口。

* 另外有些系统使用组合方式的多线程实现。一个应用程序中的多个用户级线程被映射到一些内核级线程上。

**多线程模型**

* 多对一：多个用户级线程对应一个内核级线程，线程管理在用户空间中完成。
* 一对一：将一个用户级线程映射到一个内核级线程上。
* 多对多：将n个用户级线程映射到m个内核级线程上，$m\leq n$。

## 处理机调度

### 调度的概念

**概念**

进程数量往往多于处理机的个数，因此**进程竞争**处理机在所难免。处理机调度是按照一定的算法（**公平、高效**），选择一个进程并将处理机分配给它运行，实现进程并发地执行。

处理机调度机制是多道程序操作系统的基础，是操作系统设计的核心问题。

**调度的层次**

* 作业调度：又称高级调度，按照一定的原则从**外存上**处于后备状态的作业中挑选一个或多个，给它们分配内存、输入/输出设备等必要资源，并建立相应的进程，使它们获得竞争处理机的权利。简而言之就是内存与辅存之间的调度。
* 中级调度：又称内存调度，作用是提高内存利用率和系统吞吐量。将那些暂时不能运行的进程调至外存等待，此时进程的状态称为**挂起态**。当已具备运行条件且内存又有空闲时，重新调入内存，将其修改为就绪态，挂在就绪队列等待。
* 进程调度：又称低级调度，按照某种方法和策略从就绪队列中选取一个进程将其交给处理机。进程调度的频率很高，一般几十毫秒一次。

### 调度的时机、切换与过程

进程调度和切换是操作系统内核程序。**请求调度**的事件发生后，才可能运行**进程调度**程序，调度了新的就绪程序后，才会进行**进程的切换**。这三件事在理论上是按顺序进行的，但实际中，操作系统内核程序运行时若发生了引起进程调度的因素，不一定能马上进行调度和切换：

* 在中断处理过程中。
* 进程在操作系统内核程序的临界区中。
* 其他需要完全屏蔽中断的原子操作过程中。





### 进程调度方式

调度方式指的是当某个进程正在处理机上执行时，有某个**优先权更高**的进程进入就绪队列，此时应该如何分配处理机的问题。通常由以下两种方式：

* 非剥夺调度方式：当一个进程正在处理机上执行时，即使有优先权更高的进程进入就绪队列，也要等到正在执行的进程完成或发生某种事件而进入阻塞状态，才把处理机分给优先权更高的进程。这种方式适用于大多数批处理操作系统。
* 剥夺调度方式：立即暂停正在执行的进程，将处理机分配给这个优先级更高的进程。这种方式对提供系统吞吐率和响应效率都有明显好处，但这不是一种任意行为，要遵循一定原则。

### 调度的基本准则

为了比较处理机调度算法的性能，提出了以下一些评价准则：

* CPU利用率
* 系统吞吐量：单位时间内CPU完成作业的数量
* 周转时间：从作业提交到作业完成所经历的事件
* 等待时间：进程处于等处理机状态的时间之和，等待时间越长，用户满意度越低
* 响应时间：用户提交请求到系统首次产生响应的时间。

### 典型的调度算法

**先来先服务(FCFS)调度算法**

是最简单的调度算法，既可用于作业调度，又可用于进程调度。该算法每次从后备作业队列中选择最先进入该队列的一个或多个作业，调入内存，分配必要资源，创建进程并放入就绪队列。

该算法属于不可剥夺算法。算法简单，但效率低。对长作业有利，对短作业不利。

**短作业优先(SJF)调度算法**

对短作业优先调度。从后备队列中选择一个运行时间最短的作业，调入内存中。

缺点：

* 对长作业不利，可能导致长作业长期不被调度。
* 未完全考虑作业的紧迫程度，不能保证紧迫性任务被及时处理。
* 作业长短是根据用户提供的预估时间而定的，用户可能有意或无意地缩短其作业预估时间，不一定能真正做到短作业优先。

**优先级调度算法**

既可以用于作业调度，又可以用于进程调度。

根据新的更高优先级进程能否抢占正在执行的进程，可将调度算法分为：

* 非剥夺式优先级调度
* 剥夺式优先级调度

根据进程创建后其优先级是否可以改变，将进程优先级分为：

* 静态优先级：优先级在进程创建时决定，且在进程的整个运行时期内不变。
* 动态优先级：进程运行过程中，根据进程情况的变化动态地调整优先级，主要依据有进程占有CPU时间长短、就绪进程等待CPU时间长短等。

进程优先级设置可参照以下原则：

* 系统进程>用户进程
* 交互式进程>非交互式进程
* I/O进程>计算型进程

**高响应比优先调度算法**

是对先来先服务和短作业优先两种调度算法的综合。同时考虑了每个作业的等待时间和估计的运行时间。

每次进行作业调度时，先计算后备作业队列中每个作业的响应比，选择相应比最高的作业投入运行：
$$
相应比R_P=\frac{等待时间+要求服务时间}{要求服务时间}
$$

* 作业等待时间相同时，要求服务时间越短，响应比越高，有利于短作业
* 要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，响应比越高，是先来先服务
* 对于长作业，作业的响应比随着等待时间的增加而提高，等待时间足够长，响应比便可以升到很高。

**时间片轮转调度算法**

主要适用于**分时系统**。该种算法中，系统将所有就绪进程按照到达时间的先后次序排成一个队列，进程调度程序总选择队列的第一个进程执行，但仅能运行一个时间片，例如100ms，使用完一个时间片后必须立即释放（被剥夺）处理机给下一个就绪的进程，被剥夺的进程返回就绪队列的末尾重新排队，等待再次运行。

时间片的大小对系统性能的影响很大，若时间片过大，就相当于先来先服务算法；若时间片过小，处理机将在进程间频繁切换，使其开销增大，真正用于服务进程的时间变少。需要进行适当选择，需要考虑系统响应时间、系统处理能力等。

**多组反馈队列调度算法**

是时间片轮转调度算法和优先级调度算法的综合与发展。通过**动态调整**进程**优先级和时间片大小**，可以兼顾多方面的系统目标。

实现思想如下：

* 设置多个就绪队列，每个队列设置不同的优先级，第1级队列优先级最高，逐次递减。
* 赋予各个队列中进程执行时间片的大小各不相同。优先级越高的队列中，每个进程的运行时间片越小。
* 一个新进程进入内存后，首先将其放入第一级队列的末尾，按照FCFS原则排队调度。当轮到该进程执行时，如果能在时间片内执行完，便可撤离系统；若尚未执行完，调度程序便将其转入第2级队列的末尾，再按同样的FCFS原则等待调度，以此类推直到一个进程从第1级依次降到第n级队列后，在第n级队列中按照时间片轮转的方式运行。
* 仅当第1级队列为空时，调度程序才会调度第2级队列的进程；仅当第1~(i-1)级队列都为空时才会调度第i级队列进程运行，若此时有新进程进入第1~(i-1)级队列，则进入的新进程将抢占处理机，处理机会被分配给更高优先级的进程。

优势如下：

* 终端型作业用户：短作业优先
* 短批处理作业用户：周转时间短
* 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理

## 进程同步

### 基本概念

用来协调不同进程之间的**相互制约关系**。

**临界资源**

系统中的许多资源只能为一个进程所用，我们将依次**仅允许一个进程使用的资源**称为临界资源。许多物理设备都属于临界资源。

对于临界资源的访问，必须**互斥**地进行，在每个进程中，**访问临界资源的那段代码**被称为**临界区**。我们可以把临界资源的访问过程分为4个部分：

* 进入区：在进入区要检查是否可以进入临界区，若能进入则设置正在访问临界区的标志，阻值其他进程同时进入临界区
* 临界区：进程访问临界资源的那段代码
* 退出区：将正在访问临界区的标志清除
* 剩余区：代码中的其余部分

**同步**

同步也称直接制约关系，指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的**工作次序**而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的**合作**。

**互斥**

互斥也称**间接制约**关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用资源的进程退出临界后，另一个进程才允许访问此临界资源。

为禁止两个进程同时进入临界区，同步机制应遵循以下准则：

* 空闲让进
* 忙则等待
* 有限等待：对于请求访问的进程，应保证其能在有限时间内进入临界区
* 让权等待：当进程不能进入临界区时，应立即释放进程，防止进程忙等待

### 实现临界区互斥的基本方法

**软件实现方法**

在进入去设置并检查一些标志来表明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。

* 单标志法：设置一个公用整型变量turn，用于指示被允许进入临界区的进程标号，即若turn=0，则允许$P_0$进程进入临界区。该算法可以确保每次只允许一个进程进入临界区。两个进程必须交替进入临界区，若某个进程不再进入临界区，另一个进程也无法进入临界区（因为turn没有改变），这样容易造成资源浪费。

```c
//P_0进程
while(turn != 0);
critical section;
turn = 1;
remainder section;
```

* 双标志法先检查：在每个进程访问临界区资源之前，先检查临界资源是否正在被访问，若正被访问，则进程需要等待；邹泽进程才能进入自己的临界区。为此设置一个数据$flag[i]$，如第i个元素值为FALSE，表示$P_i$进程未进入临界区，值为TRUE，表示该进程进入临界区。优点：不用交替进入，可连续使用。缺点：两个进程可能同时进入临界区。
* 双标志法后检查：上一个算法线检测对方进程状态再置自己的标志，由于再检测和防止中可插入另一个进程到达时的检测操作，会造成两个进程再分别检测后同时进入临界区。为了该算法先将自己的标志置为TRUE，再检测对方状态标志，若对方状态标志为TRUE，则等待，否则进入临界区。两个进程几乎同时都想进入临界区，都将自己的标志置为TRUE，同时检测对方的状态，都想进入，双方相互谦让，谁也进不去，导致饥饿现象。
* Peterson's Algorithm：防止两个进程进行无限等待，又设置了一个变量turn，每个变量在先设置自己的标志后再置turn标志。这时再同时检测另一个进程状态标志和允许进入标志，保证两个进程同时要求进入临界时只允许一个进程进入。

**硬件实现方法**

* 中断屏蔽法：一个进程正在使用处理机执行其临界代码时，防止其他进程进入其临界区进行访问的方式是：禁止一切中断发生。但这样会降低执行效率，限制了处理机交替执行程序的能力。
* 硬件指令方法：
  * TestAndSet指令：该指令是原子操作，执行时不允许被中断。功能是读出指定标志后把该标志置为真。







### 信号量

信号量机制是一种功能较强的机制，可以解决互斥与同步的问题，只能被两个标准原语wait和signal访问，可记为：P操作和V操作。



**整型信号量**





**记录型信号量**





**利用信号量实现同步**





**利用信号量实现互斥**





**利用信号量实现前驱关系**











### 管程

管程的特性保证了进程互斥，降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。

**定义**





**条件变量**





### 经典同步问题









## 死锁

### 概念

**定义**

死锁是多个进程因竞争资源而造成的一种僵局（**互相等待**），若无外力作用，这些进程都将无法向前推进。

**产生的原因**

* 系统资源的竞争：通常系统中拥有的**不可剥夺资源**数量不足以满足多个进程运行的需要，使得进程在运行过程中因为资源争夺而陷入僵局。
* 进程推进顺序非法：
* 死锁产生的必要条件（以下4个要同时满足才能产生死锁）
  * 互斥条件：
  * 不剥夺条件：
  * 请求并保持条件：
  * 循环等待条件：



### 处理策略







### 死锁预防





### 死锁避免







### 死锁检测和解除

