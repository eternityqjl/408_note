## 进程与线程

### 进程的概念和特征

**概念**

多道程序环境下，引入进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的**并发性和共享性**。

为了使得参与并发执行的程序(包含数据)能够独立地运行，必须为之配置一个专门的数据结构，称为**进程控制块(PCB)**。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由**程序段、相关数据段和PCB**三部分构成了**进程映像**（实体）。创建进程实质上是创建**进程映像中的PCB**，撤销进程实际上是撤销进程的PCB。

PCB是**进程存在**的唯一标志。

**特征**

* 动态性：进程是程序的依次执行，它有着创建、活动、暂停、终止等过程，具有一定的**生命周期**。
* 并发性：多个进程实体同时存在于**内存**中。
* 独立性：进程实体是一个能独立运行、独立获得资源、独立接受调度的基本单位
* 异步性：进程之间相互制约，按照各自独立的、不可预知的速度向前推进；异步性会导致执行结果不可再现，因此在操作系统中必须配置相应的同步机制。
* 结构性：进程实体由程序段、数据段、PCB三部分组成。

### 进程的状态与转换

* **运行态**：进程正在处理机上运行。单处理机环境下每个时刻最多只有一个进程处于运行态。
* **就绪态**：进程获得除了处理机外的一切资源，一旦获得处理机资源，就可以立即运行。系统中可能有多个处于就绪态的进程，它们排成一个队列，称为就绪队列。
* **阻塞态**（等待态）：进程正在等待某一时间而暂停，可能是I/O完成或等待某资源成为可用。
* 创建态：进程正在被创建，尚未转到就绪态。创建过程：首先申请一个PCB，并向PCB中写入一些控制和管理进程的信息，然后系统为进程分配所需的资源，最后把进程转入就绪态。
* 结束态：进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。

整个系统的3种基本状态之间的转换：

* 就绪态$\rightarrow$运行态
* 运行态$\rightarrow$就绪态：处于运行态的程序在时间片用完后不得不让出处理机，从而从运行态转为就绪态
* 运行态$\rightarrow$阻塞态：进程请求某一资源的使用和分配或登台某一之间的发生时，就从运行态转换为阻塞态
* 阻塞态$\rightarrow$就绪态：进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应的进程的状态转换为就绪态

### 进程控制

对系统中所有进程实施有效的管理，具有**创建新进程、撤销已有进程、实现进程状态转换**等功能。操作系统中一般把**进程控制用的程序段**称为**原语**。原语执行期间不允许中断，是一个不可分割的单位。

**进程的创建**

允许一个进程创建另一个进程，创建者称为父进程，被创建的进程称为子进程，子进程可以继承父进程拥有的资源。

操作系统创建一个新进程（原语）的过程如下：

* 为新进程分配一个唯一的进程标识号（PID），并申请一个**空白的PCB**。
* 为进程分配资源，即必要的**内存空间**；若资源不足，并不是创建失败，而是处于阻塞态
* **初始化PCB**，主要包括初始化标志信息、处理机状态信息和控制信息、进程的优先级
* 若就绪队列能够接纳新进程，则将新进程**插入就绪队列**

**进程的终止**

引起进程终止的事件有：

* 正常结束，任务已经完成准备退出运行
* 异常结束，进程运行时发生了异常事件，如存储区越界、非法指令等。
* 外界干预：进程应外界的请求而终止运行，如操作系统干预、父进程终止等。

操作系统终止进程的过程；

* 根据终止进程的PID，检索PCB，从中读出进程状态
* 若处于执行状态，则立即终止该进程，将处理机资源释放
* 若该进程有子孙进程，则将所有子孙进程终止
* 将该进程的所有资源归还
* 将该PCB从所在队列（链表）中删除

**进程的阻塞和唤醒**

正在执行的进程，由于期待某些事情发生，如等待某种操作的完成、新数据尚未到达等，由系统自动执行**阻塞原语Block**，使自己由运行态变为阻塞态；阻塞是进程自身的一种行为，只有处于运行态的进程才能转换为阻塞态。阻塞原语的执行过程如下：

* 找到要被阻塞进程的PID对应的PCB
* 保护现场，将其状态转为阻塞态，停止运行。
* 将该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。

当被阻塞进程所期待的事件出现时，调用**唤醒原语Wakeup**将其唤醒：

* 在该事件的等待队列中找到相应进程的PCB
* 将其从等待队列中移除，置为就序列
* 将其插入就绪队列，等待调度

**进程切换**

进程切换在内核的支持下实现。进程切换指的是处理机从一个进程的运行转到另一个进程的运行，过程如下：

* 保存处理机上下文，包括程序计数器和其他寄存器
* 更新PCB信息
* 将进程的PCB移入相应队列，如就绪、在某事件阻塞等队列
* 选择另一个进程执行，更新其PCB
* 更新内存管理的数据结构
* 恢复处理机的上下文

> 注：**进程调度**是决定资源分配给哪个进程的行为，是一种**决策行为**；**进程切换**是指实际分配的行为，是**执行行为**。一般先有调度后有执行。

### 进程的组织

进程是操作系统进行资源分配和调度的基本单位。由以下三部分组成，其中最核心的时进程控制块（PCB）。

**进程控制块**

进程创建时，操作系统为其分配一个新的PCB，PCB常驻内存，任何时刻都可以存取，在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。

进程运行过程中PCB的使用：

* 系统要调度进程运行时，要从进程的PCB中查出其**现行状态和优先级**。

* 调度到某进程后，要根据PCB中的处理机状态信息设置进程的**恢复运行的现场**，根据程序和数据的内存地址，找到**程序和数据**。

* 进程运行过程中，需要**和其他进程实现同步、通信或访问文件**时，也需要访问PCB
* 当进程由于一些原因**暂停运行**时，需要将其断点的处理机环境保存到PCB中。

PCB包含的各个部分：

* 进程描述信息：进程标识符PID和用户标识符UID
* 进程控制和管理信息：当前状态、优先级
* 资源分配清单：用于说明有关内存地址空间和虚拟地址空间的状况
* 处理机相关信息：处理机中各寄存器的值，便于在该进程被重新执行时能从断电继续运行

系统组织各进程的所有PID的方式：

* 链接方式：将同一状态的PCB链接成一个**队列**，不同状态对应不同队列
* 索引方式：将同一状态的PCB组织在一个索引表中，索引表的表项指向相应的PCB

**程序段**

能被进程调度程序调度道CPU执行的代码；程序可以被多个进程共享。

**数据段**

可以是进程对应的程序加工处理的原始数据，或者程序执行时产生的中间或最终结果。

### 进程的通信

指**进程之间的信息交换**。

**共享存储**

通信进程之间存在一块可以直接访问的共享空间，通过对这块共享空间进行读/写操作实现进程之间交换信息。

对共享空间进行读写时，需要使用**同步互斥工具**（P操作、V操作）。

共享存储分为：

* 低级方式：基于数据结构的共享
* 高级方式：基于存储区的共享

操作系统只提供可共享使用的存储空间和同步互斥工具，数据交换用户自行安排读写指令完成。

**消息传递**

该系统中，进程间的数据交换以**格式化的消息**为单位。这种方法用于进程之间不存在可以直接访问的共享空间。

进程通过系统提供的发送消息和接收消息两个原语进行数据交换。

* 直接通信方式：发送进程把消息发送给接收进程，并将其挂在接收进程的缓冲队列上
* 间接通信方式：发送进程把消息发送给某个中间实体，接收进程从实体中获得消息

**管道通信**

管道（pipe文件）是用于链接一个读进程和一个写进程以实现它们之间通信的一个共享文件夹，采用半双工通信。

写进程以字符流的形式将大量数据写入管道；接收进程从管道中读数据。管道机制提供三个方面的协调能力：互斥、同步、确定管道存在。

管道和一般文件有所不同，能克服使用文件进行通信时的两个问题：

* 限制管道的大小。管道是一个固定大小的缓冲区。
* 读进程可能比写进程快，当管道中所有数据已经被读取完后，这时管道中read()调用将被默认阻塞

### 线程概念和多线程模型

**线程基本概念**
引入线程的目的是减小程序在**并发执行**时所付出的开销，提高操作系统的并发性能。

线程的直接理解就是轻量级进程，它是一个**基本的CPU执行单元**，也是程序执行流的**最小单元**，由线程ID、程序计数器、寄存器集合和堆栈组成。

线程是进程中的一个实体，是被系统独立调度和分配的基本单元，线程自己不拥有系统资源，而是与其他属于同一进程的多个线程共享进程的所有资源。

一个线程可以创建和撤销另一个线程，同一进程中的多个线程可以并发执行。线程之间相互制约，运行中存在间断性，拥有运行态、就绪态和阻塞态三种状态。

引入线程后，进程的内涵发生了变化，只作为除了CPU外系统资源的分配单元，线程则作为处理机的分配单元。线程之间的切换只需要花费很少的时空空间。

线程切换时只需要保存和设置少量寄存器，开销很小。另外多个线程共享进程的地址空间，同步和通信很容易实现，无需系统干预。

**线程的实现方式**

* 用户级线程：有关线程管理的所有工作都由应用程序完成，内核和意识不到线程的存在，应用程序通过线程库来实现。
* 内核级线程：线程管理的所有工作由内核完成，线程管理对应用程序透明，只有一个到内核级线程的编程接口。

* 另外有些系统使用组合方式的多线程实现。一个应用程序中的多个用户级线程被映射到一些内核级线程上。

**多线程模型**

* 多对一：多个用户级线程对应一个内核级线程，线程管理在用户空间中完成。
* 一对一：将一个用户级线程映射到一个内核级线程上。
* 多对多：将n个用户级线程映射到m个内核级线程上，$m\leq n$。

## 处理机调度

### 调度的概念

**概念**

进程数量往往多于处理机的个数，因此**进程竞争**处理机在所难免。处理机调度是按照一定的算法（**公平、高效**），选择一个进程并将处理机分配给它运行，实现进程并发地执行。

处理机调度机制是多道程序操作系统的基础，是操作系统设计的核心问题。

**调度的层次**

* 作业调度：又称高级调度，按照一定的原则从**外存上**处于后备状态的作业中挑选一个或多个，给它们分配内存、输入/输出设备等必要资源，并建立相应的进程，使它们获得竞争处理机的权利。简而言之就是内存与辅存之间的调度。
* 中级调度：又称内存调度，作用是提高内存利用率和系统吞吐量。将那些暂时不能运行的进程调至外存等待，此时进程的状态称为**挂起态**。当已具备运行条件且内存又有空闲时，重新调入内存，将其修改为就绪态，挂在就绪队列等待。
* 进程调度：又称低级调度，按照某种方法和策略从就绪队列中选取一个进程将其交给处理机。进程调度的频率很高，一般几十毫秒一次。

### 调度的时机、切换与过程

进程调度和切换是操作系统内核程序。**请求调度**的事件发生后，才可能运行**进程调度**程序，调度了新的就绪程序后，才会进行**进程的切换**。这三件事在理论上是按顺序进行的，但实际中，操作系统内核程序运行时若发生了引起进程调度的因素，不一定能马上进行调度和切换：

* 在中断处理过程中。
* 进程在操作系统内核程序的临界区中。
* 其他需要完全屏蔽中断的原子操作过程中。





### 进程调度方式

调度方式指的是当某个进程正在处理机上执行时，有某个**优先权更高**的进程进入就绪队列，此时应该如何分配处理机的问题。通常由以下两种方式：

* 非剥夺调度方式：当一个进程正在处理机上执行时，即使有优先权更高的进程进入就绪队列，也要等到正在执行的进程完成或发生某种事件而进入阻塞状态，才把处理机分给优先权更高的进程。这种方式适用于大多数批处理操作系统。
* 剥夺调度方式：立即暂停正在执行的进程，将处理机分配给这个优先级更高的进程。这种方式对提供系统吞吐率和响应效率都有明显好处，但这不是一种任意行为，要遵循一定原则。

### 调度的基本准则

为了比较处理机调度算法的性能，提出了以下一些评价准则：

* CPU利用率
* 系统吞吐量：单位时间内CPU完成作业的数量
* 周转时间：从作业提交到作业完成所经历的事件
* 等待时间：进程处于等处理机状态的时间之和，等待时间越长，用户满意度越低
* 响应时间：用户提交请求到系统首次产生响应的时间。

### 典型的调度算法

**先来先服务(FCFS)调度算法**

是最简单的调度算法，既可用于作业调度，又可用于进程调度。该算法每次从后背作业队列中选择最先进入该队列的一个或多个作业，点入内存，分配必要资源，创建进程并放入就绪队列。

该算法属于不可剥夺算法。算法简单，但效率低。对长作业有利，对短作业不利。

**短作业优先(SJF)调度算法**

对短作业优先调度。从后背队列中选择一个运行时间最短的作业，调入内存中。

缺点：

* 对长作业不利，可能导致长作业长期不被调度。
* 未完全考虑作业的紧迫程度，不能保证紧迫性任务被及时处理。
* 作业长短是根据用户提供的预估时间而定的，用户可能有意或无意地缩短其作业预估时间，不一定能真正做到短作业优先。

**优先级调度算法**





**高响应比优先调度算法**





**时间片轮转调度算法**





**多组反馈队列调度算法**







## 进程同步

### 基本概念

用来协调不同进程之间的**相互制约关系**。

**临界资源**

系统中的许多资源只能为一个进程所用，我们将依次**仅允许一个进程使用的资源**称为临界资源。许多物理设备都属于临界资源。

对于临界资源的访问，必须**互斥**地进行，在每个进程中，访问临界资源的那段代码被称为**临界区**。我们可以把临界资源的访问过程分为4个部分：

* 进入区：
* 临界区
* 退出区
* 剩余区



**同步**

同步也称直接制约关系，指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的**工作次序**而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的**合作**。



**互斥**

互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用资源的进程退出临界后，另一个进程才允许访问此临界资源。

为禁止两个进程同时进入临界区，同步机制应遵循以下准则：

* 空闲让进
* 忙则等待
* 有限等待
* 让权等待

### 实现临界区互斥的基本方法

**软件实现方法**





**硬件实现方法**









### 信号量

信号量机制是一种功能较强的机制，可以解决互斥与同步的问题，只能被两个标准原语wait和signal访问，可记为：P操作和V操作。



**整型信号量**





**记录型信号量**





**利用信号量实现同步**





**利用信号量实现互斥**





**利用信号量实现前驱关系**











### 管程

管程的特性保证了进程互斥，降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。

**定义**





**条件变量**





### 经典同步问题









## 死锁

### 概念

**定义**

死锁是多个进程因竞争资源而造成的一种僵局（**互相等待**），若无外力作用，这些进程都将无法向前推进。

**产生的原因**

* 系统资源的竞争：通常系统中拥有的**不可剥夺资源**数量不足以满足多个进程运行的需要，使得进程在运行过程中因为资源争夺而陷入僵局。
* 进程推进顺序非法：
* 死锁产生的必要条件（以下4个要同时满足才能产生死锁）
  * 互斥条件：
  * 不剥夺条件：
  * 请求并保持条件：
  * 循环等待条件：



### 处理策略







### 死锁预防





### 死锁避免







### 死锁检测和解除

