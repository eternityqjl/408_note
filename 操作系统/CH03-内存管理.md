本章围绕**分页机制**展开，通过分页管理方式在物理内存大小的基础上提高内存的利用率，再进一步引入请求分页管理方式，实现虚拟内存，使内存脱离物理大小的限制，从而提高处理器的利用率。

## 内存管理概念

### 基本原理和要求

内存管理的功能有：

* 内存空间的分配与回收
* 地址转换
* 内存的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
* 存储保护

**程序装入和链接**

创建进程首先要将程序和数据装入内存。将源程序变为可在内存中运行的程序，需要以下步骤：

* **编译**：将源代码编译成若干目标模块
* **链接**：将编译后形成的目标模块和所需的库函数链接在一起，形成完整的**装入模块**
* **装入**：由装入程序将装入模块装入内存

程序的链接有以下三种方式：

* **静态链接**：程序运行前，链接为一个完成的可执行程序，以后不再拆开
* **装入时动态链接**：目标模块装入内存时边装入边链接
* **运行时动态链接**：对某些目标模块，在程序执行过程中需要该目标模块时才进行链接，便于修改和更新，与程序**逻辑结构**相关。

内存的装入模块在装入内存时同样有三种方式：

* **绝对装入**：程序将驻留在内存中的某个位置，则编译将产生**绝对地址**的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。无需对程序和数据的地址进行修改。只适用于**单道程序环境**。
* **可重定位装入**：多道程序环境下，**多个目标模块**的起始地址通常都**从0开始**，程序中的其他地址都是相对于始址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入内存的适当位置。装入时对目标程序中的指令和数据的修改过程称为重定位。特点是一个作业装入内存时必须**分配要求的全部内存空间**，若内存不够则无法装入。
* **动态运行时装入**：装入程序把装入模块装入内存后，不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序**真正要执行时**才进行。装入后的所有地址为相对地址。

**逻辑地址空间与物理地址空间**

地址重定位：将逻辑地址转换为物理地址。

**内存保护**

内存分配前需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护的两种方式：

* 在CPU中设置一对**上下限寄存器**，存放用户作业在主存中的上限和下限地址，当CPU要访问一个地址时进行比较，判断**是否越界**。
* 采用**重定位寄存器**和**界地址寄存器**实现。重定位寄存器包含**最小的物理地址**，界地址寄存器包含**逻辑地址的最大值**。每个逻辑地址必须**小于**界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若**未发生越界**，则加上重定位寄存器后的值映射为**物理地址**，然后送交内存单元

### \*覆盖与交换

在多道程序环境下用来扩充内存。

**覆盖**

早期单道用户系统的内存放不下用户进程。因此把用户空间分成**一个固定区和若干覆盖区**。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前再调入覆盖区。

覆盖区打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍然不能运行。

**交换**

把处于等待状态的程序从内存移到辅存，把内存腾出来，称为**换出**。把准备好竞争CPU运行的程序从辅存移入内存，称为**换入**。第2章中的中级调度采用的就是交换技术。

需要注意的问题：

* 交换需要备份存储
* 为了提高效率，每个进程的执行时间要比交换时间长。
* 换出程序时必须保证该进程完全处于空闲状态
* 交换空间通常作为磁盘的一整块，独立于文件系统。
* 交换通常在许多进程运行且内存空间紧张时开始启动，系统负荷降低后就停止。

### 连续分配管理方式

指为一个用户程序分配一个连续的内存空间。

**单一连续分配**

内存在此方式下分为**用户区**和**系统区**，系统区仅供**操作系统**使用，在**低地址**部分；用户区是为**用户**提供的、除系统区之外的内存空间。这种方式**无需进行内存保护**。内存中永远只有一道程序。

这种方式只能用于**单用户、单任务**的操作系统中，有**内部碎片**，存储器的利用率低。

**固定分区分配**

将用户空间划分为**若干固定大小的区域**，每个分区只装入**一道作业**。当有空闲分区时便可从外存的后备作业队列中选择适当大小的作业装入该分区。

固定分区分配在划分时有两种不同方法：

* 分区大小**相等**
* 分区大小**不相等**

为了便于内存分配通常将分区按照大小排队，并为之建立一张**分区说明表**，其中包括每个分区的**始址、大小及状态**（是否已分配）。

这种方式的问题：

* 程序可能太大而放不进任何一个分区中
* 主存利用率低，当程序小于固定分区大小时，一部分内存空间就浪费了，称为**内部碎片**

**动态分区分配**

这种方法不预先划分内存，而是在进程装入内存时，**根据进程的大小**动态地建立分区，并使分区的大小整合适合进程的需要。

动态分区在开始分配时是很好的，但之后会导致内存中出现许多小的内存块，随着时间的推移产生越来越多的碎片，内存利用率随之下降。这些小内存块称为**外部碎片**。

在进程装入或换入主存时，若内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，考虑以下几种算法：

* **首次适应算法**：空闲分区以**地址递增**的次序链接。分配时顺序查找，找到大小能满足的第一个分区。
* **最佳适应算法**：空闲分区以**容量递增**的方式形成分区链，找到第一个能满足要求的空闲分区
* **最坏适应（最大适应）算法**：空闲分区以**容量递减**的次序链接。
* 邻近适应算法：又称循环首次适应算法。由首次适应演变而来。不同之处时分配内存时从上次查找结束的位置开始继续查找。

### 非连续管理分配方式

允许一个程序分散地装入不相邻的内存分区。

非连续分配管理方式根据**分区的大小是否固定**，分为**分页**存储管理方式和**分段**存储管理方式。

分页存储管理方式中，又根据运行时是否要把作业的所有页面都装入内存中才能运行，分为**基本**分页存储管理方式和**请求**分页存储管理方式。

**基本分页存储管理方式**

分页的思想：把**主存空间**划分为大小相等且固定的**块**，块相对较小，作为主存的基本单位。**每个进程**也以块为单位进行划分，进程执行时以块为单位逐个申请内存中的块空间。

**（1）几个概念**

* 页面和页面大小：**进程中的块**称为**页**，内存中的块称为**页框**。外存也以同样的单位进行划分，直接称为**块**。进程执行时需要申请主存空间，即要为每个页面分配主存中可用的页框。（每页大小一般为4KB）

* 地址结构：（地址长度为32位）

  * 页号P：12~31位为页号，地址空间最多允许$2^{20}$页
  * 页内偏移量W：0-11位为页内地址，即每页大小为4KB

  **地址结构**决定了虚拟内存的**寻址空间**有多大。

* 页表：由页表项构成：

  * 页号
  * 物理内存中的块号

配置页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。

**（2）基本地址变换机构**

从逻辑地址到物理地址的转换，该过程由硬件自动完成。详见书上的内容步骤。

**（3）具有快表的地址变换机构**

**快表**为地址变换机构中的一个具有并行查找能力的高速缓冲器，又称**相联存储器TLB**。与此对应，内存中的页表通常称为**慢表**。

慢表存取一条数据或指令需要进行**两次**访存，而使用快表仅需**一次**。题目中常出现x路组相联的TLB，由此可以计算出组索引的位数，然后根据虚拟内存总位数和页内地址位数算出TLB标记的位数，从虚拟地址出分离出TLB标记。

具有快表的分页机制中，地址变换过程如下：

* CPU给出逻辑地址后由硬件进行地址转换，将页号送入高速缓冲存储器，并将此页号与快表中所有页号进行比较
* 若找到匹配的页号，说明所要访问的页表项在快表中，直接从中取出该页对应的页框号（物理块号），与页内偏移地址拼接形成物理地址。如此便可实现一次访问存取数据。
* 若未找到匹配的页号，则要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。

快表命中率可以达到90%以上，快表的有效性基于局部性原理。

**（3）两级页表**

建立页表的页表，详情见书上的例子。

顶级页表最多只能有一个页面。

**基本分段存储管理方式**

分区大小不固定

分段考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长以及动态链接等多方面的需求。

* 分段：逻辑地址由**段号S**与**段内偏移量W**组合而成。

  页式系统中逻辑地址的**页号和页内偏移量对用户是透明**的，而段式系统中，**段号和段内偏移量**必须**由用户显示提供**。高级程序设计语言中，这个工作由**编译器**完成。

* 段表：逻辑空间与内存空间的映射表。每个段表项对应进程的一段，段表项记录该段在内存中的**始址**和**长度**。配置段表后，执行中的进程可以通过查找段表，找到每段对应的内存区。

* 地址变换机构：
  * 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。
  * **比较段号S和段表长度M**，如果S大于等于M，则产生**越界中断**，否则继续执行。
  * 段表中段号S对应的段表项地址=段表始地址F+段号S*段表项长度，取出段表项的前几位得到段长C，如果**段内偏移量大于等于段长C**，则产生**越界中断**。
  * 取出段表项中该段的始址b，计算得到物理地址E=b+W，用E去访问内存。

* 段的共享与保护
  * 段的共享：通过两个作业的段表中相应表项**指向被共享的段的同一个物理副本**来实现。
  * 段的保护：
    * 存取控制保护
    * 地址越界保护：将段表寄存器中的段表长度与逻辑地址中的段号S进行比较，若段号大于段表长度则产生越界中断；再将段表项中的段长与逻辑地址中的段内偏移量进行比较，若段内偏移大于段长，也会产生越界中断。

段式管理不能通过给出一个整数便确定对应物理地址，因为每段的长度不固定，无法通过整数除法直接得到段号。

**段页式管理方式**

页式存储管理能有效提高内存利用率，分段存储管理能反映程序的逻辑结构并有利于段的共享。段页式存储将这两种方法结合起来。

该系统中，作业的地址空间首先被分成**若干逻辑段**，每段都有自己的**段号**，然后将每个段分为若干**大小固定的页**。对物理内存的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的**存储块**。

段页式系统中，作业的**逻辑地址**分为三部分：**段号、页号和页内偏移量**。

为了实现地址变换，系统为每个进程建立一个**段表**，每个分段有一张**页表**。段表中包括**段号、页表长度和页表始址**，页表表项中至少包括**页号和块号**。此外系统还有一个**段表寄存器**，指出作业的段表始址和段表长度。

一个进程中，段表只有一个，页表可能有多个。每个**进程**对应**一个段表**，**每段**对应**一个页表**，**段的长度**必须是**页长的整数倍**，段的起点必须是某一页的起点。

地址变换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最后形成物理地址。进行一次访问实际需要三次访问主存，这里同样可以使用**快表**来加快查找速度，其关键字由**段号、页号**组成。

段页式管理的地址空间是**二维**的。

## 虚拟内存管理

### 基本概念

**传统存储管理方式的特征**

上一节的内存策略都是为了同时将多个进程保存在内存中，以便允许多道程序设计。它们有以下共同特征：

* **一次性**：作业必须一次性全部装入内存后才能开始运行
* **驻留性**：作业装入内存后，就一直驻留在内存中，任何部分都不会被换出，直到作业结束。

许多在程序运行中不用或暂时不用的程序（数据）占据了大量内存空间，而一些需要运行的作业又无法装入，浪费了宝贵的内存资源。

**局部性原理**

高速缓存。

* 时间局部性：程序中某条指令一旦执行，不久后可能再次执行。典型原因是程序中存在大量循环操作
* 空间局部性：一旦程序访问了某个存储单元，不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的。

内存-外存两级存储结构，利用局部原理实现了高速缓存。

**虚拟存储器的定义和特征**

程序装入时，将程序的**一部分装入内存**，而将**其余部分留在外存**，就可启动程序。程序执行过程中当所访问的信息不在内存中时，由操作系统将所需的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存，从而腾出空间存放将要调入内存的信息。

这种虚拟存储器实际上不存在，只是由系统提供了部分装入、请求调入和置换功能。虚拟存储器的大小由计算机的地址结构决定。

虚拟存储器有以下特征：

* **多次性**：无须在作业时一次性地全部装入内存，允许被分成多次调入内存运行
* **对换性**：无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出。
* **虚拟性**：从逻辑上扩充内存容量

**虚拟内存技术的实现**

虚拟内存的实现需要建立在**离散分配的内存管理方式**的基础上。

虚拟内存的实现有以下方式：

* **请求分页**存储管理
* **请求分段**存储管理
* **请求段页式**存储管理

不管是以上哪种方式，都需要硬件支持：

* 一定容量的内存和外存
* **页表**机制，作为主要的数据结构
* **中断**机构，当用户程序要访问的部分尚未调入内存时，则产生中断
* **地址变换**机构，逻辑地址到物理地址的变换

### 请求分页管理方式

建立在基本分页系统基础之上。为了支持虚拟存储器功能增加了**请求调页**功能和**页面置换**功能。

该系统中，只要求将当前需要的**一部分页面**装入内存，便可启动作业。作业执行过程中，当所要访问的页面不在内存中时，通过**调页**功能将其调入，同时还可以通过**页面置换**将暂时不用的页面换出到外存上，以便腾出内存空间。

**页表机制**

发现和处理需要访问的页面不在内存中的情况。

请求页表项中增加了4个字段：

| 页号 | 物理块号 | 状态位P | 访问字段A | 修改位M | 外存地址 |
| ---- | -------- | ------- | --------- | ------- | -------- |

* **状态位P**：用于指示该页**是否已经调入**内存
* **访问字段A**：用于记录本页在一段时间内**被访问的次数**，为置换算法提供参考
* **修改位M**：标识该页在调入内存后**是否被修改过**
* **外存地址**：指出该页在外存上的地址，通常是物理块号

**缺页中断机制**

每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。

与一般中断相比，具有以下两个明显区别：

* 在**指令执行期间**而非一条指令执行完成后产生和处理中断信号，属于**内部中断**
* 一条指令在执行期间可能产生**多次缺页中断**

**地址变换机构**

* 首先检索**快表**
* 若找到要访问的页，则修改页表项中的**访问位**（写指令还需重置修改位），然后利用页表中给出的物理块号和页内地址偏移形成**物理地址**
* 若未找到该页的页表项，则到**内存中去查找页表**，再对比页表项中的状态位，看该页是否调入内存，未调入则产生缺页中断，请求将该页从外存调入内存。

### 页面置换算法

进程运行时，若其访问的页面不在内存中而需将其调入，但内存中已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。

**选择调出页面**的算法就称为页面置换算法。好的页面置换算法应有**较低的页面更换频率**，即以后不会再访问或以后较长时间不访问的页面先调出。

**最佳（OPT）置换算法**

该算法选择的被淘汰页面是**以后永不使用**的页面，或是在**最长时间内不再被访问**的页面，以保证最低的缺页率。

由于人们无法预知哪个是未来最长时间不再被访问的，因此该算法**无法实现**。但该算法可以用来评价其他算法。

**先进先出（FIFO）置换算法**

优先淘汰最早进入内存的页面，只需把调入内存的页面根据先后次序链接成队列，设置一个指针指向最早的页面即可。但该算法与进程实际运行时的规律**不符**，在进程中有些页面经常被访问。

FIFO算法还会产生所分配的物理块数增大而页**故障数不减反增**的异常现象，称为**Belady现象**。

**最近最久未使用（LRU）置换算法**

该算法为每个页面设置一个访问字段，来记录页面**上次被访问以来所经历的时间**，淘汰页面时选择现有页面中值最大的予以淘汰。

LRU算法是**向前**看的，而最佳置换算法是向后看的。

LRU算法性能较好，但需要**寄存器和栈**的硬件支持。该算法是堆栈类算法，**不会发生Belady异常**；FIFO是**队列**算法。

**时钟（CLOCK）置换算法**

算法要扫描缓冲区，像时钟的指针一样转动，所以称为CLOCK算法。

（1）简单CLOCK算法

为每个帧关联一个附加位，称为**使用位**，当某页首次装入主存时，将该帧的使用位置为1；当该页随后再被访问到时，其使用位也被置为1。页替换算法的**候选帧集合**可视为一个**循环缓冲区**，并有**一个指针**与之相关联。

当某一页被替换时，该指针被设置成指向**缓冲区的下一帧**；当需要替换一页时，操作系统扫描缓冲区，查找使用位被置为1的一帧；每当遇到一个使用位为1的帧时，操作系统就将该位**重新置为0**；若在这个过程开始时缓冲区**所有使用位都为0**，则选择**遇到的第一个帧**；若**所有帧的使用位都为1**，则指针在缓冲区**完整地循环一周**，**把所有使用位置为0**，然后选择**最初停留的帧**。

（2）改进型COLCK算法

在**使用位**的基础上，增加一个**修改位**。每帧都处于以下4中情况：（u为使用位，m为修改位）

* 最近未被访问，也未被修改（u=0，m=0）
* 最近被访问，但未被修改（u=1，m=0）
* 最近未被访问，但被修改（u=0，m=1）
* 最近被访问，被修改（u=1，m=1）



首先置换出**未使用过**的页面，如果所有页面都被使用过，则首先置换**未修改过**的页面，最后再置换**使用过且修改过**的页面。

### 页面分配策略

**驻留集大小**

进程准备执行时，不需要也不可能把一个进程的所有页都读入内存。操作系统要决定给特定进程分配几个页框。给一个进程分配的**物理页框的集合**就是这个进程的**驻留集**。需要考虑以下因素：

* 分配给一个进程的存储量越小，驻留在主存中的进程数就越多，时间利用率越高。
* 一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然较高。
* 若页数过多，则由于局部性原理，分配更多内存空间也不会影响错误率。

因此，常采用以下策略：

* **固定分配局部置换**：为每个进程分配一定数目的物理块，在**整个运行期间都不变**。若进程发生缺页，则只能从该进程在内存的页面中**选择一页换出**，然后**调入**需要的页面。这种策略难以确定为每个进程分配的物理块数；太少会频繁缺页，太多会使其他资源使用率下降。

* **可变分配全局置换**：为每个进程分配一定数目的物理块，**操作系统**也保持一个**空闲的物理块队列**。当进程发生缺页时，系统从空闲物理块队列**取出一个物理块**分配给该进程。这种方法会盲目给进程增加物理块，导致多道程序并发能力下降。

* **可变分配局部置换**：为每个进程分配一定数目的物理块，发生缺页时，**只允许从该进程在内存的页面中选择一页换出**，不会影响其他进程运行；当进程在运行中**频繁缺页**，则系统再为该进程**分配一定数据物理块**，直到进程的**缺页率趋于适当**；若进程运行的**缺页率特别低**，则可适当**减少分配给该进程的物理块**。这种方法既能动态增加物理块数量，还能动态减少进程物理块数量，既保证不会过多调页，又能保证系统的多道程序并发性能。

**调入页面的时机**

用来确定进程将运行时所缺的页面调入内存的时机，可采取以下策略：

* **预调页策略**：采取以**预测**为基础的预调页策略，将预计在不久后便会访问的页面预先调入内存。但目前**成功率为50%左右**。这种策略主要用于进程的**首次调入**。

* **请求调页策略**：缺页时系统提出调用请求，每次只调入一页，调入调出页面时会花费**过多的I/O开销**。

**从何处调入页面**

请求分页系统的**外存**分为两部分：用于存放文件的**文件区**和用于存放对换页面的**对换区**。文件区采用**离散**分配方式，对换区采用**连续**分配方式，对换区的**I/O速度更快**。

* 系统拥有足够的对换区空间时：**全部从对换区**调入页面。
* 系统缺少足够的对换区空间时：凡是**不会修改**的文件都直接从**文件区**调入；换出这些页面时，由于他们未被修改而不必将其换出。对于那些**可能被修改**的部分，在其换出时调到**对换区**，以后需要时再从对换区调入。
* UNIX方式：**与进程有关**的文件都放在**文件区**，因此从未运行过的页面都从文件区调入；**曾经运行过又被换出**的页面，由于存放在对换区，下次调入是应从**对换区**调入。

### 抖动

页面置换过程中，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存，这种频繁的页面调度行为称为抖动或颠簸。若一个进程**在换页上用的时间多于执行时间**，则这个进程就在颠簸。

### 工作集

工作集指在某段**时间间隔内**进程**要访问的页面集合**。工作集反映了再接下来的一段时间内**很可能频繁访问的页面集合**。

工作集由时间t和窗口大小$\Delta$来确定。一般分配给进程的物理块数要大于工作集的大小。

落在工作集中的页面需要**调入驻留集**，落在工作集外的页面可以**从驻留集中换出**。

### 地址翻译

结合高速缓存分析从虚拟内存访问的过程。

查找顺序从TLB表到页表（TLB不命中），再到Cache和主存，最后到外存。

![虚拟地址和物理地址的结构](https://raw.githubusercontent.com/eternityqjl/blogGallery/master/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BB%93%E6%9E%84.jpg)





